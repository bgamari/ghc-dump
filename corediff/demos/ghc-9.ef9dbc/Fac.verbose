[1 of 1] Compiling Fac              ( Fac.hs, Fac.o )

==================== Desugar (before optimization) ====================
Result size of Desugar (before optimization)
  = {terms: 57, types: 46, coercions: 0, joins: 0/10}

Rec {
-- RHS size: {terms: 5, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX]
Fac.$trModule
  = GHC.Types.Module
      (GHC.Types.TrNameS "main"#) (GHC.Types.TrNameS "Fac"#)

-- RHS size: {terms: 50, types: 37, coercions: 0, joins: 0/10}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX]
fac
  = \ (@p_aIJ) ($dEq_aPP :: Eq p_aIJ) ($dNum_aPQ :: Num p_aIJ) ->
      let {
        $dNum_aIH :: Num p_aIJ
        [LclId]
        $dNum_aIH = $dNum_aPQ } in
      let {
        $dEq_aHO :: Eq p_aIJ
        [LclId]
        $dEq_aHO = $dEq_aPP } in
      let {
        $dNum_aIV :: Num p_aIJ
        [LclId]
        $dNum_aIV = $dNum_aIH } in
      let {
        $dNum_aIT :: Num p_aIJ
        [LclId]
        $dNum_aIT = $dNum_aIH } in
      let {
        $dNum_aIN :: Num p_aIJ
        [LclId]
        $dNum_aIN = $dNum_aIH } in
      let {
        $dNum_aIL :: Num p_aIJ
        [LclId]
        $dNum_aIL = $dNum_aIH } in
      letrec {
        fac_aj3 :: p_aIJ -> p_aIJ
        [LclId]
        fac_aj3
          = \ (ds_dQf :: p_aIJ) ->
              let {
                fail_dQg :: (# #) -> p_aIJ
                [LclId]
                fail_dQg
                  = \ (ds_dQh [OS=OneShot] :: (# #)) ->
                      Control.Exception.Base.patError
                        @'GHC.Types.LiftedRep
                        @p_aIJ
                        "Fac.hs:(3,1)-(4,21)|function fac"# } in
              let {
                n_agb :: p_aIJ
                [LclId]
                n_agb = ds_dQf } in
              let {
                fail_dQi :: (# #) -> p_aIJ
                [LclId]
                fail_dQi
                  = \ (ds_dQj [OS=OneShot] :: (# #)) ->
                      * @p_aIJ
                        $dNum_aIN
                        n_agb
                        (fac_aj3
                           (- @p_aIJ $dNum_aIT n_agb (fromInteger @p_aIJ $dNum_aIV 1))) } in
              case == @p_aIJ $dEq_aHO ds_dQf (fromInteger @p_aIJ $dNum_aIH 0)
              of wild_00 {
                False -> fail_dQi GHC.Prim.void#;
                True -> fromInteger @p_aIJ $dNum_aIL 1
              }; } in
      fac_aj3
end Rec }




==================== Desugar (after optimization) ====================
Result size of Desugar (after optimization)
  = {terms: 35, types: 25, coercions: 0, joins: 0/1}

-- RHS size: {terms: 28, types: 16, coercions: 0, joins: 0/1}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150] 570 0}]
fac
  = \ (@p_aIJ) ($dEq_aPP :: Eq p_aIJ) ($dNum_aPQ :: Num p_aIJ) ->
      letrec {
        fac_aj3 [Occ=LoopBreaker] :: p_aIJ -> p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 550 0}]
        fac_aj3
          = \ (ds_dQf :: p_aIJ) ->
              case == @p_aIJ $dEq_aPP ds_dQf (fromInteger @p_aIJ $dNum_aPQ 0)
              of {
                False ->
                  * @p_aIJ
                    $dNum_aPQ
                    ds_dQf
                    (fac_aj3
                       (- @p_aIJ $dNum_aPQ ds_dQf (fromInteger @p_aIJ $dNum_aPQ 1)));
                True -> fromInteger @p_aIJ $dNum_aPQ 1
              }; } in
      fac_aj3

-- RHS size: {terms: 5, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 10}]
Fac.$trModule
  = GHC.Types.Module
      (GHC.Types.TrNameS "main"#) (GHC.Types.TrNameS "Fac"#)




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = InitialPhase [Gentle],
             inline,
             rules,
             eta-expand,
             no case-of-case}
Result size of Simplifier
  = {terms: 45, types: 30, coercions: 0, joins: 0/1}

-- RHS size: {terms: 30, types: 17, coercions: 0, joins: 0/1}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150 0] 590 0}]
fac
  = \ (@p_aIJ)
      ($dEq_aPP :: Eq p_aIJ)
      ($dNum_aPQ :: Num p_aIJ)
      (eta_B0 :: p_aIJ) ->
      letrec {
        fac_aj3 [Occ=LoopBreaker] :: p_aIJ -> p_aIJ
        [LclId,
         Arity=1,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 550 0}]
        fac_aj3
          = \ (ds_dQf :: p_aIJ) ->
              case == @p_aIJ $dEq_aPP ds_dQf (fromInteger @p_aIJ $dNum_aPQ 0)
              of {
                False ->
                  * @p_aIJ
                    $dNum_aPQ
                    ds_dQf
                    (fac_aj3
                       (- @p_aIJ $dNum_aPQ ds_dQf (fromInteger @p_aIJ $dNum_aPQ 1)));
                True -> fromInteger @p_aIJ $dNum_aPQ 1
              }; } in
      fac_aj3 eta_B0

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Specialise ====================
Result size of Specialise
  = {terms: 45, types: 30, coercions: 0, joins: 0/1}

-- RHS size: {terms: 30, types: 17, coercions: 0, joins: 0/1}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150 0] 590 0}]
fac
  = \ (@p_aIJ)
      ($dEq_aPP :: Eq p_aIJ)
      ($dNum_aPQ :: Num p_aIJ)
      (eta_B0 :: p_aIJ) ->
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_aIJ -> p_aIJ
        [LclId, Arity=1]
        fac_sQu
          = \ (ds_dQf :: p_aIJ) ->
              case == @p_aIJ $dEq_aPP ds_dQf (fromInteger @p_aIJ $dNum_aPQ 0)
              of {
                False ->
                  * @p_aIJ
                    $dNum_aPQ
                    ds_dQf
                    (fac_sQu
                       (- @p_aIJ $dNum_aPQ ds_dQf (fromInteger @p_aIJ $dNum_aPQ 1)));
                True -> fromInteger @p_aIJ $dNum_aPQ 1
              }; } in
      fac_sQu eta_B0

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Levels added: ====================
<Fac.fac,<0,0>>
<Fac.fac,<0,0>>
  = \ <p_aIJ,<1,0>>
      <$dEq_aPP,<1,0>>
      <$dNum_aPQ,<1,0>>
      <eta_B0,<1,0>> ->
      letrec {
        <fac_sQu,<1,2>>
        <fac_sQu,<1,2>>
          = \ <ds_dQf,<2,0>> ->
              case GHC.Classes.==
                     @p_aIJ
                     $dEq_aPP
                     ds_dQf
                     (let {
                        <lvl_sQw,F<1,0>>
                        <lvl_sQw,F<1,0>>
                          = GHC.Num.fromInteger
                              @p_aIJ
                              $dNum_aPQ
                              (let {
                                 <lvl_sQv,F<0,0>>
                                 <lvl_sQv,F<0,0>> = 0 } in
                               lvl_sQv) } in
                      lvl_sQw)
              of <wild_X1,<2,2>> {
                GHC.Types.False ->
                  GHC.Num.*
                    @p_aIJ
                    $dNum_aPQ
                    ds_dQf
                    (fac_sQu
                       (GHC.Num.-
                          @p_aIJ
                          $dNum_aPQ
                          ds_dQf
                          (let {
                             <lvl_sQy,F<1,0>>
                             <lvl_sQy,F<1,0>>
                               = GHC.Num.fromInteger
                                   @p_aIJ
                                   $dNum_aPQ
                                   (let {
                                      <lvl_sQx,F<0,0>>
                                      <lvl_sQx,F<0,0>> = 1 } in
                                    lvl_sQx) } in
                           lvl_sQy)));
                GHC.Types.True ->
                  let {
                    <lvl_sQA,F<1,0>>
                    <lvl_sQA,F<1,0>>
                      = GHC.Num.fromInteger
                          @p_aIJ
                          $dNum_aPQ
                          (let {
                             <lvl_sQz,F<0,0>>
                             <lvl_sQz,F<0,0>> = 1 } in
                           lvl_sQz) } in
                  lvl_sQA
              }; } in
      fac_sQu eta_B0
<$trModule_sQn,<0,0>>
<$trModule_sQn,<0,0>> = "main"#
<$trModule_sQo,<0,0>>
<$trModule_sQo,<0,0>> = GHC.Types.TrNameS $trModule_sQn
<$trModule_sQp,<0,0>>
<$trModule_sQp,<0,0>> = "Fac"#
<$trModule_sQq,<0,0>>
<$trModule_sQq,<0,0>> = GHC.Types.TrNameS $trModule_sQp
<Fac.$trModule,<0,0>>
<Fac.$trModule,<0,0>>
  = GHC.Types.Module $trModule_sQo $trModule_sQq



==================== Float out(FOS {Lam = Just 0, Consts = True, OverSatApps = False}) ====================
Result size of Float out(FOS {Lam = Just 0,
                              Consts = True,
                              OverSatApps = False})
  = {terms: 57, types: 36, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQz :: Integer
[LclId]
lvl_sQz = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId]
lvl_sQv = 0

-- RHS size: {terms: 36, types: 20, coercions: 0, joins: 0/4}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX, Arity=3]
fac
  = \ (@p_aIJ)
      ($dEq_aPP :: Eq p_aIJ)
      ($dNum_aPQ :: Num p_aIJ)
      (eta_B0 :: p_aIJ) ->
      let {
        lvl_sQy :: p_aIJ
        [LclId]
        lvl_sQy = fromInteger @p_aIJ $dNum_aPQ lvl_sQx } in
      let {
        lvl_sQA :: p_aIJ
        [LclId]
        lvl_sQA = fromInteger @p_aIJ $dNum_aPQ lvl_sQz } in
      let {
        lvl_sQw :: p_aIJ
        [LclId]
        lvl_sQw = fromInteger @p_aIJ $dNum_aPQ lvl_sQv } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_aIJ -> p_aIJ
        [LclId, Arity=1]
        fac_sQu
          = \ (ds_dQf :: p_aIJ) ->
              case == @p_aIJ $dEq_aPP ds_dQf lvl_sQw of {
                False ->
                  * @p_aIJ
                    $dNum_aPQ
                    ds_dQf
                    (fac_sQu (- @p_aIJ $dNum_aPQ ds_dQf lvl_sQy));
                True -> lvl_sQA
              }; } in
      fac_sQu eta_B0

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 2 [main],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 57, types: 36, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQz :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQz = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQv = 0

-- RHS size: {terms: 36, types: 20, coercions: 0, joins: 0/4}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150 0] 320 0}]
fac
  = \ (@p_aIJ)
      ($dEq_aPP :: Eq p_aIJ)
      ($dNum_aPQ :: Num p_aIJ)
      (eta_B0 :: p_aIJ) ->
      let {
        lvl_sQy :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQy = fromInteger @p_aIJ $dNum_aPQ lvl_sQx } in
      let {
        lvl_sQA :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQA = fromInteger @p_aIJ $dNum_aPQ lvl_sQz } in
      let {
        lvl_sQw :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQw = fromInteger @p_aIJ $dNum_aPQ lvl_sQv } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_aIJ -> p_aIJ
        [LclId,
         Arity=1,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 160 0}]
        fac_sQu
          = \ (ds_dQf :: p_aIJ) ->
              case == @p_aIJ $dEq_aPP ds_dQf lvl_sQw of {
                False ->
                  * @p_aIJ
                    $dNum_aPQ
                    ds_dQf
                    (fac_sQu (- @p_aIJ $dNum_aPQ ds_dQf lvl_sQy));
                True -> lvl_sQA
              }; } in
      fac_sQu eta_B0

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 1 [main],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 57, types: 36, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQz :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQz = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQv = 0

-- RHS size: {terms: 36, types: 20, coercions: 0, joins: 0/4}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150 0] 320 0}]
fac
  = \ (@p_aIJ)
      ($dEq_aPP :: Eq p_aIJ)
      ($dNum_aPQ :: Num p_aIJ)
      (eta_B0 :: p_aIJ) ->
      let {
        lvl_sQy :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQy = fromInteger @p_aIJ $dNum_aPQ lvl_sQx } in
      let {
        lvl_sQA :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQA = fromInteger @p_aIJ $dNum_aPQ lvl_sQz } in
      let {
        lvl_sQw :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQw = fromInteger @p_aIJ $dNum_aPQ lvl_sQv } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_aIJ -> p_aIJ
        [LclId,
         Arity=1,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 160 0}]
        fac_sQu
          = \ (ds_dQf :: p_aIJ) ->
              case == @p_aIJ $dEq_aPP ds_dQf lvl_sQw of {
                False ->
                  * @p_aIJ
                    $dNum_aPQ
                    ds_dQf
                    (fac_sQu (- @p_aIJ $dNum_aPQ ds_dQf lvl_sQy));
                True -> lvl_sQA
              }; } in
      fac_sQu eta_B0

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 0 [main],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 57, types: 36, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQz :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQz = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQv = 0

-- RHS size: {terms: 36, types: 20, coercions: 0, joins: 0/4}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150 0] 320 0}]
fac
  = \ (@p_aIJ)
      ($dEq_aPP :: Eq p_aIJ)
      ($dNum_aPQ :: Num p_aIJ)
      (eta_B0 :: p_aIJ) ->
      let {
        lvl_sQy :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQy = fromInteger @p_aIJ $dNum_aPQ lvl_sQx } in
      let {
        lvl_sQA :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQA = fromInteger @p_aIJ $dNum_aPQ lvl_sQz } in
      let {
        lvl_sQw :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQw = fromInteger @p_aIJ $dNum_aPQ lvl_sQv } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_aIJ -> p_aIJ
        [LclId,
         Arity=1,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 160 0}]
        fac_sQu
          = \ (ds_dQf :: p_aIJ) ->
              case == @p_aIJ $dEq_aPP ds_dQf lvl_sQw of {
                False ->
                  * @p_aIJ
                    $dNum_aPQ
                    ds_dQf
                    (fac_sQu (- @p_aIJ $dNum_aPQ ds_dQf lvl_sQy));
                True -> lvl_sQA
              }; } in
      fac_sQu eta_B0

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Float inwards ====================
Result size of Float inwards
  = {terms: 57, types: 36, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQz :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQz = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQv = 0

-- RHS size: {terms: 36, types: 20, coercions: 0, joins: 0/4}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150 0] 320 0}]
fac
  = \ (@p_aIJ)
      ($dEq_aPP :: Eq p_aIJ)
      ($dNum_aPQ :: Num p_aIJ)
      (eta_B0 :: p_aIJ) ->
      let {
        lvl_sQw :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQw = fromInteger @p_aIJ $dNum_aPQ lvl_sQv } in
      let {
        lvl_sQA :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQA = fromInteger @p_aIJ $dNum_aPQ lvl_sQz } in
      let {
        lvl_sQy :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQy = fromInteger @p_aIJ $dNum_aPQ lvl_sQx } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_aIJ -> p_aIJ
        [LclId,
         Arity=1,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 160 0}]
        fac_sQu
          = \ (ds_dQf :: p_aIJ) ->
              case == @p_aIJ $dEq_aPP ds_dQf lvl_sQw of {
                False ->
                  * @p_aIJ
                    $dNum_aPQ
                    ds_dQf
                    (fac_sQu (- @p_aIJ $dNum_aPQ ds_dQf lvl_sQy));
                True -> lvl_sQA
              }; } in
      fac_sQu eta_B0

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Called arity analysis ====================
Result size of Called arity analysis
  = {terms: 57, types: 36, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQz :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQz = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQv = 0

-- RHS size: {terms: 36, types: 20, coercions: 0, joins: 0/4}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150 0] 320 0}]
fac
  = \ (@p_aIJ)
      ($dEq_aPP :: Eq p_aIJ)
      ($dNum_aPQ :: Num p_aIJ)
      (eta_B0 :: p_aIJ) ->
      let {
        lvl_sQw :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQw = fromInteger @p_aIJ $dNum_aPQ lvl_sQv } in
      let {
        lvl_sQA :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQA = fromInteger @p_aIJ $dNum_aPQ lvl_sQz } in
      let {
        lvl_sQy :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQy = fromInteger @p_aIJ $dNum_aPQ lvl_sQx } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_aIJ -> p_aIJ
        [LclId,
         Arity=1,
         CallArity=1,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 160 0}]
        fac_sQu
          = \ (ds_dQf :: p_aIJ) ->
              case == @p_aIJ $dEq_aPP ds_dQf lvl_sQw of {
                False ->
                  * @p_aIJ
                    $dNum_aPQ
                    ds_dQf
                    (fac_sQu (- @p_aIJ $dNum_aPQ ds_dQf lvl_sQy));
                True -> lvl_sQA
              }; } in
      fac_sQu eta_B0

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [post-call-arity],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 57, types: 36, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQz :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQz = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQv = 0

-- RHS size: {terms: 36, types: 20, coercions: 0, joins: 0/4}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150 0] 320 0}]
fac
  = \ (@p_aIJ)
      ($dEq_aPP :: Eq p_aIJ)
      ($dNum_aPQ :: Num p_aIJ)
      (eta_B0 :: p_aIJ) ->
      let {
        lvl_sQw :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQw = fromInteger @p_aIJ $dNum_aPQ lvl_sQv } in
      let {
        lvl_sQA :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQA = fromInteger @p_aIJ $dNum_aPQ lvl_sQz } in
      let {
        lvl_sQy :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQy = fromInteger @p_aIJ $dNum_aPQ lvl_sQx } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_aIJ -> p_aIJ
        [LclId,
         Arity=1,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 160 0}]
        fac_sQu
          = \ (ds_dQf :: p_aIJ) ->
              case == @p_aIJ $dEq_aPP ds_dQf lvl_sQw of {
                False ->
                  * @p_aIJ
                    $dNum_aPQ
                    ds_dQf
                    (fac_sQu (- @p_aIJ $dNum_aPQ ds_dQf lvl_sQy));
                True -> lvl_sQA
              }; } in
      fac_sQu eta_B0

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Demand analysis ====================
Result size of Demand analysis
  = {terms: 57, types: 36, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQz :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQz = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQv = 0

-- RHS size: {terms: 36, types: 20, coercions: 0, joins: 0/4}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150 0] 320 0}]
fac
  = \ (@p_aIJ)
      ($dEq_aPP [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq p_aIJ)
      ($dNum_aPQ [Dmd=<L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))>]
         :: Num p_aIJ)
      (eta_B0 :: p_aIJ) ->
      let {
        lvl_sQw :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQw = fromInteger @p_aIJ $dNum_aPQ lvl_sQv } in
      let {
        lvl_sQA :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQA = fromInteger @p_aIJ $dNum_aPQ lvl_sQz } in
      let {
        lvl_sQy :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQy = fromInteger @p_aIJ $dNum_aPQ lvl_sQx } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_aIJ -> p_aIJ
        [LclId,
         Arity=1,
         Str=<L,U> {aPP-><S(C(C(S))L),U(C(C1(U)),A)>},
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 160 0}]
        fac_sQu
          = \ (ds_dQf :: p_aIJ) ->
              case == @p_aIJ $dEq_aPP ds_dQf lvl_sQw of {
                False ->
                  * @p_aIJ
                    $dNum_aPQ
                    ds_dQf
                    (fac_sQu (- @p_aIJ $dNum_aPQ ds_dQf lvl_sQy));
                True -> lvl_sQA
              }; } in
      fac_sQu eta_B0

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Constructed Product Result analysis ====================
Result size of Constructed Product Result analysis
  = {terms: 57, types: 36, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQz :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQz = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQv = 0

-- RHS size: {terms: 36, types: 20, coercions: 0, joins: 0/4}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150 0] 320 0}]
fac
  = \ (@p_aIJ)
      ($dEq_aPP [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq p_aIJ)
      ($dNum_aPQ [Dmd=<L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))>]
         :: Num p_aIJ)
      (eta_B0 :: p_aIJ) ->
      let {
        lvl_sQw :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQw = fromInteger @p_aIJ $dNum_aPQ lvl_sQv } in
      let {
        lvl_sQA :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQA = fromInteger @p_aIJ $dNum_aPQ lvl_sQz } in
      let {
        lvl_sQy :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQy = fromInteger @p_aIJ $dNum_aPQ lvl_sQx } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_aIJ -> p_aIJ
        [LclId,
         Arity=1,
         Str=<L,U> {aPP-><S(C(C(S))L),U(C(C1(U)),A)>},
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 160 0}]
        fac_sQu
          = \ (ds_dQf :: p_aIJ) ->
              case == @p_aIJ $dEq_aPP ds_dQf lvl_sQw of {
                False ->
                  * @p_aIJ
                    $dNum_aPQ
                    ds_dQf
                    (fac_sQu (- @p_aIJ $dNum_aPQ ds_dQf lvl_sQy));
                True -> lvl_sQA
              }; } in
      fac_sQu eta_B0

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Worker Wrapper binds ====================
Result size of Worker Wrapper binds
  = {terms: 83, types: 79, coercions: 0, joins: 0/9}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQz :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQz = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQv = 0

-- RHS size: {terms: 50, types: 38, coercions: 0, joins: 0/9}
$wfac_sQT [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>]
$wfac_sQT
  = \ (@p_sQK)
      (ww_sQQ [Dmd=<C(C(S)),C(C1(U))>] :: p_sQK -> p_sQK -> Bool)
      (w_sQM [Dmd=<L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))>] :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      let {
        ww_sQR [Dmd=<L,A>] :: p_sQK -> p_sQK -> Bool
        [LclId, Str=b, Cpr=b]
        ww_sQR
          = Control.Exception.Base.absentError
              @(p_sQK -> p_sQK -> Bool) "ww p -> p -> Bool"# } in
      let {
        w_sQL [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq p_sQK
        [LclId]
        w_sQL = GHC.Classes.C:Eq @p_sQK ww_sQQ ww_sQR } in
      let {
        @p_aIJ
        p_aIJ = TYPE: p_sQK } in
      let {
        $dEq_aPP [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq p_aIJ
        [LclId]
        $dEq_aPP = w_sQL } in
      let {
        $dNum_aPQ [Dmd=<L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))>] :: Num p_aIJ
        [LclId]
        $dNum_aPQ = w_sQM } in
      let {
        eta_B0 :: p_aIJ
        [LclId]
        eta_B0 = w_sQN } in
      let {
        lvl_sQw :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQw = fromInteger @p_aIJ $dNum_aPQ lvl_sQv } in
      let {
        lvl_sQA :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQA = fromInteger @p_aIJ $dNum_aPQ lvl_sQz } in
      let {
        lvl_sQy :: p_aIJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQy = fromInteger @p_aIJ $dNum_aPQ lvl_sQx } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_aIJ -> p_aIJ
        [LclId,
         Arity=1,
         Str=<L,U>,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 160 0}]
        fac_sQu
          = \ (ds_dQf :: p_aIJ) ->
              case == @p_aIJ $dEq_aPP ds_dQf lvl_sQw of {
                False ->
                  * @p_aIJ
                    $dNum_aPQ
                    ds_dQf
                    (fac_sQu (- @p_aIJ $dNum_aPQ ds_dQf lvl_sQy));
                True -> lvl_sQA
              }; } in
      fac_sQu eta_B0

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p_sQK)
      (w_sQL [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq p_sQK)
      (w_sQM [Dmd=<L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))>] :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      case w_sQL of ww_sQP
      { GHC.Classes.C:Eq ww_sQQ [Dmd=<C(C(S)),C(C1(U))>]
                         ww_sQR [Dmd=<L,A>] ->
      $wfac_sQT @p_sQK ww_sQQ w_sQM w_sQN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [post-worker-wrapper],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 68, types: 61, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQz :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQz = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQv = 0

-- RHS size: {terms: 35, types: 20, coercions: 0, joins: 0/4}
$wfac_sQT [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 150 0] 310 0}]
$wfac_sQT
  = \ (@p_sQK)
      (ww_sQQ :: p_sQK -> p_sQK -> Bool)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      let {
        lvl_sQw :: p_sQK
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQw = fromInteger @p_sQK w_sQM lvl_sQv } in
      let {
        lvl_sQA :: p_sQK
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQA = fromInteger @p_sQK w_sQM lvl_sQz } in
      let {
        lvl_sQy :: p_sQK
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQy = fromInteger @p_sQK w_sQM lvl_sQx } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_sQK -> p_sQK
        [LclId,
         Arity=1,
         Str=<L,U>,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
        fac_sQu
          = \ (ds_dQf :: p_sQK) ->
              case ww_sQQ ds_dQf lvl_sQw of {
                False ->
                  * @p_sQK w_sQM ds_dQf (fac_sQu (- @p_sQK w_sQM ds_dQf lvl_sQy));
                True -> lvl_sQA
              }; } in
      fac_sQu w_sQN

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p_sQK)
      (w_sQL :: Eq p_sQK)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      case w_sQL of
      { GHC.Classes.C:Eq ww_sQQ [Dmd=<C(C(S)),C(C1(U))>]
                         ww_sQR [Dmd=<L,A>] ->
      $wfac_sQT @p_sQK ww_sQQ w_sQM w_sQN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Exitification transformation ====================
Result size of Exitification transformation
  = {terms: 68, types: 61, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQz :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQz = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQv = 0

-- RHS size: {terms: 35, types: 20, coercions: 0, joins: 0/4}
$wfac_sQT [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 150 0] 310 0}]
$wfac_sQT
  = \ (@p_sQK)
      (ww_sQQ :: p_sQK -> p_sQK -> Bool)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      let {
        lvl_sQw :: p_sQK
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQw = fromInteger @p_sQK w_sQM lvl_sQv } in
      let {
        lvl_sQA :: p_sQK
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQA = fromInteger @p_sQK w_sQM lvl_sQz } in
      let {
        lvl_sQy :: p_sQK
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQy = fromInteger @p_sQK w_sQM lvl_sQx } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_sQK -> p_sQK
        [LclId,
         Arity=1,
         Str=<L,U>,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
        fac_sQu
          = \ (ds_dQf :: p_sQK) ->
              case ww_sQQ ds_dQf lvl_sQw of {
                False ->
                  * @p_sQK w_sQM ds_dQf (fac_sQu (- @p_sQK w_sQM ds_dQf lvl_sQy));
                True -> lvl_sQA
              }; } in
      fac_sQu w_sQN

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p_sQK)
      (w_sQL :: Eq p_sQK)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      case w_sQL of
      { GHC.Classes.C:Eq ww_sQQ [Dmd=<C(C(S)),C(C1(U))>]
                         ww_sQR [Dmd=<L,A>] ->
      $wfac_sQT @p_sQK ww_sQQ w_sQM w_sQN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Levels added: ====================
<lvl_sQx,<0,0>>
<lvl_sQx,<0,0>> = 1
<lvl_sQz,<0,0>>
<lvl_sQz,<0,0>> = 1
<lvl_sQv,<0,0>>
<lvl_sQv,<0,0>> = 0
<$wfac_sQT,<0,0>>
<$wfac_sQT,<0,0>>
  = \ <p_sQK,<1,0>> <ww_sQQ,<1,0>> <w_sQM,<1,0>> <w_sQN,<1,0>> ->
      let {
        <lvl_sQw,<1,2>>
        <lvl_sQw,<1,2>> = GHC.Num.fromInteger @p_sQK w_sQM lvl_sQv } in
      let {
        <lvl_sQA,<1,3>>
        <lvl_sQA,<1,3>> = GHC.Num.fromInteger @p_sQK w_sQM lvl_sQz } in
      let {
        <lvl_sQy,<1,4>>
        <lvl_sQy,<1,4>> = GHC.Num.fromInteger @p_sQK w_sQM lvl_sQx } in
      letrec {
        <fac_sQu,<1,5>>
        <fac_sQu,<1,5>>
          = \ <ds_dQf,<2,0>> ->
              case ww_sQQ ds_dQf lvl_sQw of <wild_X1,<2,2>> {
                GHC.Types.False ->
                  GHC.Num.*
                    @p_sQK
                    w_sQM
                    ds_dQf
                    (fac_sQu (GHC.Num.- @p_sQK w_sQM ds_dQf lvl_sQy));
                GHC.Types.True -> lvl_sQA
              }; } in
      fac_sQu w_sQN
<Fac.fac,<0,0>>
<Fac.fac,<0,0>>
  = \ <p_sQK,<1,0>> <w_sQL,<1,0>> <w_sQM,<1,0>> <w_sQN,<1,0>> ->
      case w_sQL of <ww_sQP,<1,2>>
      { GHC.Classes.C:Eq <ww_sQQ,<1,2>> <ww_sQR,<1,2>> ->
      $wfac_sQT @p_sQK ww_sQQ w_sQM w_sQN
      }
<$trModule_sQn,<0,0>>
<$trModule_sQn,<0,0>> = "main"#
<$trModule_sQo,<0,0>>
<$trModule_sQo,<0,0>> = GHC.Types.TrNameS $trModule_sQn
<$trModule_sQp,<0,0>>
<$trModule_sQp,<0,0>> = "Fac"#
<$trModule_sQq,<0,0>>
<$trModule_sQq,<0,0>> = GHC.Types.TrNameS $trModule_sQp
<Fac.$trModule,<0,0>>
<Fac.$trModule,<0,0>>
  = GHC.Types.Module $trModule_sQo $trModule_sQq



==================== Float out(FOS {Lam = Just 0, Consts = True, OverSatApps = True}) ====================
Result size of Float out(FOS {Lam = Just 0,
                              Consts = True,
                              OverSatApps = True})
  = {terms: 68, types: 61, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQz :: Integer
[LclId]
lvl_sQz = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId]
lvl_sQv = 0

-- RHS size: {terms: 35, types: 20, coercions: 0, joins: 0/4}
$wfac_sQT [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>]
$wfac_sQT
  = \ (@p_sQK)
      (ww_sQQ :: p_sQK -> p_sQK -> Bool)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      let {
        lvl_sQw :: p_sQK
        [LclId]
        lvl_sQw = fromInteger @p_sQK w_sQM lvl_sQv } in
      let {
        lvl_sQA :: p_sQK
        [LclId]
        lvl_sQA = fromInteger @p_sQK w_sQM lvl_sQz } in
      let {
        lvl_sQy :: p_sQK
        [LclId]
        lvl_sQy = fromInteger @p_sQK w_sQM lvl_sQx } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_sQK -> p_sQK
        [LclId, Arity=1, Str=<L,U>]
        fac_sQu
          = \ (ds_dQf :: p_sQK) ->
              case ww_sQQ ds_dQf lvl_sQw of {
                False ->
                  * @p_sQK w_sQM ds_dQf (fac_sQu (- @p_sQK w_sQM ds_dQf lvl_sQy));
                True -> lvl_sQA
              }; } in
      fac_sQu w_sQN

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p_sQK)
      (w_sQL :: Eq p_sQK)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      case w_sQL of
      { GHC.Classes.C:Eq ww_sQQ [Dmd=<C(C(S)),C(C1(U))>]
                         ww_sQR [Dmd=<L,A>] ->
      $wfac_sQT @p_sQK ww_sQQ w_sQM w_sQN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Common sub-expression ====================
Result size of Common sub-expression
  = {terms: 66, types: 60, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQz :: Integer
[LclId]
lvl_sQz = lvl_sQx

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId]
lvl_sQv = 0

-- RHS size: {terms: 33, types: 19, coercions: 0, joins: 0/4}
$wfac_sQT [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>]
$wfac_sQT
  = \ (@p_sQK)
      (ww_sQQ :: p_sQK -> p_sQK -> Bool)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      let {
        lvl_sQw :: p_sQK
        [LclId]
        lvl_sQw = fromInteger @p_sQK w_sQM lvl_sQv } in
      let {
        lvl_sQA :: p_sQK
        [LclId]
        lvl_sQA = fromInteger @p_sQK w_sQM lvl_sQx } in
      let {
        lvl_sQy :: p_sQK
        [LclId]
        lvl_sQy = lvl_sQA } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_sQK -> p_sQK
        [LclId, Arity=1, Str=<L,U>]
        fac_sQu
          = \ (ds_dQf :: p_sQK) ->
              case ww_sQQ ds_dQf lvl_sQw of wild_X1 {
                False ->
                  * @p_sQK w_sQM ds_dQf (fac_sQu (- @p_sQK w_sQM ds_dQf lvl_sQA));
                True -> lvl_sQA
              }; } in
      fac_sQu w_sQN

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p_sQK)
      (w_sQL :: Eq p_sQK)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      case w_sQL of ww_sQP
      { GHC.Classes.C:Eq ww_sQQ [Dmd=<C(C(S)),C(C1(U))>]
                         ww_sQR [Dmd=<L,A>] ->
      $wfac_sQT @p_sQK ww_sQQ w_sQM w_sQN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Float inwards ====================
Result size of Float inwards
  = {terms: 64, types: 59, coercions: 0, joins: 0/3}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQz :: Integer
[LclId]
lvl_sQz = lvl_sQx

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId]
lvl_sQv = 0

-- RHS size: {terms: 31, types: 18, coercions: 0, joins: 0/3}
$wfac_sQT [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>]
$wfac_sQT
  = \ (@p_sQK)
      (ww_sQQ :: p_sQK -> p_sQK -> Bool)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      let {
        lvl_sQA :: p_sQK
        [LclId]
        lvl_sQA = fromInteger @p_sQK w_sQM lvl_sQx } in
      let {
        lvl_sQw :: p_sQK
        [LclId]
        lvl_sQw = fromInteger @p_sQK w_sQM lvl_sQv } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_sQK -> p_sQK
        [LclId, Arity=1, Str=<L,U>]
        fac_sQu
          = \ (ds_dQf :: p_sQK) ->
              case ww_sQQ ds_dQf lvl_sQw of wild_X1 {
                False ->
                  * @p_sQK w_sQM ds_dQf (fac_sQu (- @p_sQK w_sQM ds_dQf lvl_sQA));
                True -> lvl_sQA
              }; } in
      fac_sQu w_sQN

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p_sQK)
      (w_sQL :: Eq p_sQK)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      case w_sQL of ww_sQP
      { GHC.Classes.C:Eq ww_sQQ [Dmd=<C(C(S)),C(C1(U))>]
                         ww_sQR [Dmd=<L,A>] ->
      $wfac_sQT @p_sQK ww_sQQ w_sQM w_sQN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [final],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 62, types: 58, coercions: 0, joins: 0/3}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQv = 0

-- RHS size: {terms: 31, types: 18, coercions: 0, joins: 0/3}
$wfac_sQT [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 120 0] 270 0}]
$wfac_sQT
  = \ (@p_sQK)
      (ww_sQQ :: p_sQK -> p_sQK -> Bool)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      let {
        lvl_sQA :: p_sQK
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQA = fromInteger @p_sQK w_sQM lvl_sQx } in
      let {
        lvl_sQw :: p_sQK
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQw = fromInteger @p_sQK w_sQM lvl_sQv } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_sQK -> p_sQK
        [LclId,
         Arity=1,
         Str=<L,U>,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
        fac_sQu
          = \ (ds_dQf :: p_sQK) ->
              case ww_sQQ ds_dQf lvl_sQw of {
                False ->
                  * @p_sQK w_sQM ds_dQf (fac_sQu (- @p_sQK w_sQM ds_dQf lvl_sQA));
                True -> lvl_sQA
              }; } in
      fac_sQu w_sQN

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p_sQK)
      (w_sQL :: Eq p_sQK)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      case w_sQL of
      { GHC.Classes.C:Eq ww_sQQ [Dmd=<C(C(S)),C(C1(U))>]
                         ww_sQR [Dmd=<L,A>] ->
      $wfac_sQT @p_sQK ww_sQQ w_sQM w_sQN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Liberate case ====================
Result size of Liberate case
  = {terms: 62, types: 58, coercions: 0, joins: 0/3}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQv = 0

-- RHS size: {terms: 31, types: 18, coercions: 0, joins: 0/3}
$wfac_sQT [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 120 0] 270 0}]
$wfac_sQT
  = \ (@p_sQK)
      (ww_sQQ :: p_sQK -> p_sQK -> Bool)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      let {
        lvl_sQA :: p_sQK
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQA = fromInteger @p_sQK w_sQM lvl_sQx } in
      let {
        lvl_sQw :: p_sQK
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQw = fromInteger @p_sQK w_sQM lvl_sQv } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_sQK -> p_sQK
        [LclId,
         Arity=1,
         Str=<L,U>,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
        fac_sQu
          = \ (ds_dQf :: p_sQK) ->
              case ww_sQQ ds_dQf lvl_sQw of {
                False ->
                  * @p_sQK w_sQM ds_dQf (fac_sQu (- @p_sQK w_sQM ds_dQf lvl_sQA));
                True -> lvl_sQA
              }; } in
      fac_sQu w_sQN

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p_sQK)
      (w_sQL :: Eq p_sQK)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      case w_sQL of
      { GHC.Classes.C:Eq ww_sQQ [Dmd=<C(C(S)),C(C1(U))>]
                         ww_sQR [Dmd=<L,A>] ->
      $wfac_sQT @p_sQK ww_sQQ w_sQM w_sQN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [post-liberate-case],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 62, types: 58, coercions: 0, joins: 0/3}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQv = 0

-- RHS size: {terms: 31, types: 18, coercions: 0, joins: 0/3}
$wfac_sQT [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 120 0] 270 0}]
$wfac_sQT
  = \ (@p_sQK)
      (ww_sQQ :: p_sQK -> p_sQK -> Bool)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      let {
        lvl_sQA :: p_sQK
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQA = fromInteger @p_sQK w_sQM lvl_sQx } in
      let {
        lvl_sQw :: p_sQK
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQw = fromInteger @p_sQK w_sQM lvl_sQv } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_sQK -> p_sQK
        [LclId,
         Arity=1,
         Str=<L,U>,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
        fac_sQu
          = \ (ds_dQf :: p_sQK) ->
              case ww_sQQ ds_dQf lvl_sQw of {
                False ->
                  * @p_sQK w_sQM ds_dQf (fac_sQu (- @p_sQK w_sQM ds_dQf lvl_sQA));
                True -> lvl_sQA
              }; } in
      fac_sQu w_sQN

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p_sQK)
      (w_sQL :: Eq p_sQK)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      case w_sQL of
      { GHC.Classes.C:Eq ww_sQQ [Dmd=<C(C(S)),C(C1(U))>]
                         ww_sQR [Dmd=<L,A>] ->
      $wfac_sQT @p_sQK ww_sQQ w_sQM w_sQN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== SpecConstr ====================
Result size of SpecConstr
  = {terms: 62, types: 58, coercions: 0, joins: 0/3}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId]
lvl_sQv = 0

-- RHS size: {terms: 31, types: 18, coercions: 0, joins: 0/3}
$wfac_sQT [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>]
$wfac_sQT
  = \ (@p_sQK)
      (ww_sQQ :: p_sQK -> p_sQK -> Bool)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      let {
        lvl_sQA :: p_sQK
        [LclId]
        lvl_sQA = fromInteger @p_sQK w_sQM lvl_sQx } in
      let {
        lvl_sQw :: p_sQK
        [LclId]
        lvl_sQw = fromInteger @p_sQK w_sQM lvl_sQv } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_sQK -> p_sQK
        [LclId, Arity=1, Str=<L,U>]
        fac_sQu
          = \ (ds_dQf :: p_sQK) ->
              case ww_sQQ ds_dQf lvl_sQw of {
                False ->
                  * @p_sQK w_sQM ds_dQf (fac_sQu (- @p_sQK w_sQM ds_dQf lvl_sQA));
                True -> lvl_sQA
              }; } in
      fac_sQu w_sQN

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p_sQK)
      (w_sQL :: Eq p_sQK)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      case w_sQL of
      { GHC.Classes.C:Eq ww_sQQ [Dmd=<C(C(S)),C(C1(U))>]
                         ww_sQR [Dmd=<L,A>] ->
      $wfac_sQT @p_sQK ww_sQQ w_sQM w_sQN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [post-spec-constr],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 62, types: 58, coercions: 0, joins: 0/3}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQv = 0

-- RHS size: {terms: 31, types: 18, coercions: 0, joins: 0/3}
$wfac_sQT [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 120 0] 270 0}]
$wfac_sQT
  = \ (@p_sQK)
      (ww_sQQ :: p_sQK -> p_sQK -> Bool)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      let {
        lvl_sQA :: p_sQK
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQA = fromInteger @p_sQK w_sQM lvl_sQx } in
      let {
        lvl_sQw :: p_sQK
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQw = fromInteger @p_sQK w_sQM lvl_sQv } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_sQK -> p_sQK
        [LclId,
         Arity=1,
         Str=<L,U>,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
        fac_sQu
          = \ (ds_dQf :: p_sQK) ->
              case ww_sQQ ds_dQf lvl_sQw of {
                False ->
                  * @p_sQK w_sQM ds_dQf (fac_sQu (- @p_sQK w_sQM ds_dQf lvl_sQA));
                True -> lvl_sQA
              }; } in
      fac_sQu w_sQN

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p_sQK)
      (w_sQL :: Eq p_sQK)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      case w_sQL of
      { GHC.Classes.C:Eq ww_sQQ [Dmd=<C(C(S)),C(C1(U))>]
                         ww_sQR [Dmd=<L,A>] ->
      $wfac_sQT @p_sQK ww_sQQ w_sQM w_sQN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Common sub-expression ====================
Result size of Common sub-expression
  = {terms: 62, types: 58, coercions: 0, joins: 0/3}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId]
lvl_sQv = 0

-- RHS size: {terms: 31, types: 18, coercions: 0, joins: 0/3}
$wfac_sQT [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>]
$wfac_sQT
  = \ (@p_sQK)
      (ww_sQQ :: p_sQK -> p_sQK -> Bool)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      let {
        lvl_sQA :: p_sQK
        [LclId]
        lvl_sQA = fromInteger @p_sQK w_sQM lvl_sQx } in
      let {
        lvl_sQw :: p_sQK
        [LclId]
        lvl_sQw = fromInteger @p_sQK w_sQM lvl_sQv } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_sQK -> p_sQK
        [LclId, Arity=1, Str=<L,U>]
        fac_sQu
          = \ (ds_dQf :: p_sQK) ->
              case ww_sQQ ds_dQf lvl_sQw of wild_X1 {
                False ->
                  * @p_sQK w_sQM ds_dQf (fac_sQu (- @p_sQK w_sQM ds_dQf lvl_sQA));
                True -> lvl_sQA
              }; } in
      fac_sQu w_sQN

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p_sQK)
      (w_sQL :: Eq p_sQK)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      case w_sQL of ww_sQP
      { GHC.Classes.C:Eq ww_sQQ [Dmd=<C(C(S)),C(C1(U))>]
                         ww_sQR [Dmd=<L,A>] ->
      $wfac_sQT @p_sQK ww_sQQ w_sQM w_sQN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [post-final-cse],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 62, types: 58, coercions: 0, joins: 0/3}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQv = 0

-- RHS size: {terms: 31, types: 18, coercions: 0, joins: 0/3}
$wfac_sQT [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 120 0] 270 0}]
$wfac_sQT
  = \ (@p_sQK)
      (ww_sQQ :: p_sQK -> p_sQK -> Bool)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      let {
        lvl_sQA :: p_sQK
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQA = fromInteger @p_sQK w_sQM lvl_sQx } in
      let {
        lvl_sQw :: p_sQK
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQw = fromInteger @p_sQK w_sQM lvl_sQv } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_sQK -> p_sQK
        [LclId,
         Arity=1,
         Str=<L,U>,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
        fac_sQu
          = \ (ds_dQf :: p_sQK) ->
              case ww_sQQ ds_dQf lvl_sQw of {
                False ->
                  * @p_sQK w_sQM ds_dQf (fac_sQu (- @p_sQK w_sQM ds_dQf lvl_sQA));
                True -> lvl_sQA
              }; } in
      fac_sQu w_sQN

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p_sQK)
      (w_sQL :: Eq p_sQK)
      (w_sQM :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      case w_sQL of
      { GHC.Classes.C:Eq ww_sQQ [Dmd=<C(C(S)),C(C1(U))>]
                         ww_sQR [Dmd=<L,A>] ->
      $wfac_sQT @p_sQK ww_sQQ w_sQM w_sQN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Demand analysis ====================
Result size of Demand analysis
  = {terms: 62, types: 58, coercions: 0, joins: 0/3}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQx :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQx = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_sQv :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_sQv = 0

-- RHS size: {terms: 31, types: 18, coercions: 0, joins: 0/3}
$wfac_sQT [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 120 0] 270 0}]
$wfac_sQT
  = \ (@p_sQK)
      (ww_sQQ [Dmd=<C(C(S)),C(C1(U))>] :: p_sQK -> p_sQK -> Bool)
      (w_sQM [Dmd=<L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))>] :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      let {
        lvl_sQA :: p_sQK
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQA = fromInteger @p_sQK w_sQM lvl_sQx } in
      let {
        lvl_sQw :: p_sQK
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl_sQw = fromInteger @p_sQK w_sQM lvl_sQv } in
      letrec {
        fac_sQu [Occ=LoopBreaker] :: p_sQK -> p_sQK
        [LclId,
         Arity=1,
         Str=<L,U> {sQQ-><C(C(S)),C(C1(U))>},
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
        fac_sQu
          = \ (ds_dQf :: p_sQK) ->
              case ww_sQQ ds_dQf lvl_sQw of {
                False ->
                  * @p_sQK w_sQM ds_dQf (fac_sQu (- @p_sQK w_sQM ds_dQf lvl_sQA));
                True -> lvl_sQA
              }; } in
      fac_sQu w_sQN

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),1*U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p_sQK)
      (w_sQL [Dmd=<S(C(C(S))L),1*U(C(C1(U)),A)>] :: Eq p_sQK)
      (w_sQM [Dmd=<L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))>] :: Num p_sQK)
      (w_sQN :: p_sQK) ->
      case w_sQL of
      { GHC.Classes.C:Eq ww_sQQ [Dmd=<C(C(S)),C(C1(U))>]
                         ww_sQR [Dmd=<L,A>] ->
      $wfac_sQT @p_sQK ww_sQQ w_sQM w_sQN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQn :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQn = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQo :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQo = GHC.Types.TrNameS $trModule_sQn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sQp :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sQp = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sQq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule_sQq = GHC.Types.TrNameS $trModule_sQp

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule_sQo $trModule_sQq




==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 62, types: 58, coercions: 0, joins: 0/3}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Fac.fac2 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Fac.fac2 = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Fac.fac1 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Fac.fac1 = 0

-- RHS size: {terms: 31, types: 18, coercions: 0, joins: 0/3}
Fac.$wfac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[GblId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 120 0] 270 0}]
Fac.$wfac
  = \ (@p_sQK)
      (ww_sQQ :: p_sQK -> p_sQK -> Bool)
      (w_sQM :: Num p_sQK)
      (w1_sQN :: p_sQK) ->
      let {
        lvl_sQA :: p_sQK
        [LclId]
        lvl_sQA = fromInteger @p_sQK w_sQM Fac.fac2 } in
      let {
        lvl1_sQw :: p_sQK
        [LclId]
        lvl1_sQw = fromInteger @p_sQK w_sQM Fac.fac1 } in
      letrec {
        fac3_sQu [Occ=LoopBreaker] :: p_sQK -> p_sQK
        [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
        fac3_sQu
          = \ (ds_dQf :: p_sQK) ->
              case ww_sQQ ds_dQf lvl1_sQw of {
                False ->
                  * @p_sQK w_sQM ds_dQf (fac3_sQu (- @p_sQK w_sQM ds_dQf lvl_sQA));
                True -> lvl_sQA
              }; } in
      fac3_sQu w1_sQN

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[GblId,
 Arity=3,
 Str=<S(C(C(S))L),1*U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p_sQK)
      (w_sQL :: Eq p_sQK)
      (w1_sQM :: Num p_sQK)
      (w2_sQN :: p_sQK) ->
      case w_sQL of { GHC.Classes.C:Eq ww1_sQQ ww2_sQR ->
      Fac.$wfac @p_sQK ww1_sQQ w1_sQM w2_sQN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Fac.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule3 :: GHC.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule3 = GHC.Types.TrNameS Fac.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Fac.$trModule2 = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule1 :: GHC.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule1 = GHC.Types.TrNameS Fac.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module Fac.$trModule3 Fac.$trModule1




==================== CorePrep ====================
Result size of CorePrep
  = {terms: 68, types: 60, coercions: 0, joins: 0/5}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Fac.fac2 :: GHC.Num.Integer.Integer
[GblId, Unf=OtherCon []]
Fac.fac2 = GHC.Num.Integer.IS 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Fac.fac1 :: GHC.Num.Integer.Integer
[GblId, Unf=OtherCon []]
Fac.fac1 = GHC.Num.Integer.IS 0#

-- RHS size: {terms: 35, types: 20, coercions: 0, joins: 0/5}
Fac.$wfac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}.
     (p -> p -> GHC.Types.Bool) -> GHC.Num.Num p => p -> p
[GblId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=OtherCon []]
Fac.$wfac
  = \ (@p_sQK)
      (ww_sTe [Occ=OnceL1!] :: p_sQK -> p_sQK -> GHC.Types.Bool)
      (w_sTf :: GHC.Num.Num p_sQK)
      (w1_sTg [Occ=Once1] :: p_sQK) ->
      let {
        lvl_sTh [Occ=OnceL2] :: p_sQK
        [LclId]
        lvl_sTh = GHC.Num.fromInteger @p_sQK w_sTf Fac.fac2 } in
      let {
        lvl1_sTi [Occ=OnceL1] :: p_sQK
        [LclId]
        lvl1_sTi = GHC.Num.fromInteger @p_sQK w_sTf Fac.fac1 } in
      letrec {
        fac3_sTj [Occ=LoopBreaker] :: p_sQK -> p_sQK
        [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
        fac3_sTj
          = \ (ds_sTk :: p_sQK) ->
              case ww_sTe ds_sTk lvl1_sTi of {
                GHC.Types.False ->
                  let {
                    sat_sTn [Occ=Once1] :: p_sQK
                    [LclId]
                    sat_sTn
                      = let {
                          sat_sTm [Occ=Once1] :: p_sQK
                          [LclId]
                          sat_sTm = GHC.Num.- @p_sQK w_sTf ds_sTk lvl_sTh } in
                        fac3_sTj sat_sTm } in
                  GHC.Num.* @p_sQK w_sTf ds_sTk sat_sTn;
                GHC.Types.True -> lvl_sTh
              }; } in
      fac3_sTj w1_sTg

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
Fac.fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (GHC.Classes.Eq p, GHC.Num.Num p) => p -> p
[GblId,
 Arity=3,
 Str=<S(C(C(S))L),1*U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=OtherCon []]
Fac.fac
  = \ (@p_sQK)
      (w_sTo [Occ=Once1!] :: GHC.Classes.Eq p_sQK)
      (w1_sTp [Occ=Once1] :: GHC.Num.Num p_sQK)
      (w2_sTq [Occ=Once1] :: p_sQK) ->
      case w_sTo of
      { GHC.Classes.C:Eq ww1_sTs [Occ=Once1] _ [Occ=Dead] ->
      Fac.$wfac @p_sQK ww1_sTs w1_sTp w2_sTq
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule4 :: GHC.Prim.Addr#
[GblId, Unf=OtherCon []]
Fac.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule3 :: GHC.Types.TrName
[GblId, Unf=OtherCon []]
Fac.$trModule3 = GHC.Types.TrNameS Fac.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule2 :: GHC.Prim.Addr#
[GblId, Unf=OtherCon []]
Fac.$trModule2 = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule1 :: GHC.Types.TrName
[GblId, Unf=OtherCon []]
Fac.$trModule1 = GHC.Types.TrNameS Fac.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[GblId, Unf=OtherCon []]
Fac.$trModule = GHC.Types.Module Fac.$trModule3 Fac.$trModule1



