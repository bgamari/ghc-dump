[1 of 1] Compiling T18231           ( T18231.hs, T18231.o )

==================== Desugar (before optimization) ====================
Result size of Desugar (before optimization)
  = {terms: 34, types: 39, coercions: 0, joins: 0/1}

Rec {
-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$dApplicative
  :: Applicative (StateT Int Data.Functor.Identity.Identity)
[LclId]
$dApplicative
  = Control.Monad.Trans.State.Strict.$fApplicativeStateT
      @Data.Functor.Identity.Identity @Int $dFunctor $dMonad

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$dFunctor :: Functor Data.Functor.Identity.Identity
[LclId]
$dFunctor = Data.Functor.Identity.$fFunctorIdentity

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$dMonad :: Monad Data.Functor.Identity.Identity
[LclId]
$dMonad = $dMonad

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$dMonad :: Monad Data.Functor.Identity.Identity
[LclId]
$dMonad = Data.Functor.Identity.$fMonadIdentity

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$dNum :: Num Int
[LclId]
$dNum = $dNum

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$dNum :: Num Int
[LclId]
$dNum = GHC.Num.$fNumInt

-- RHS size: {terms: 5, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX]
T18231.$trModule
  = GHC.Types.Module
      (GHC.Types.TrNameS "main"#) (GHC.Types.TrNameS "T18231"#)

-- RHS size: {terms: 13, types: 19, coercions: 0, joins: 0/1}
m :: State Int ()
[LclIdX]
m = $ @'GHC.Types.LiftedRep
      @(StateT Int Data.Functor.Identity.Identity ())
      @(StateT Int Data.Functor.Identity.Identity ())
      (forever
         @(StateT Int Data.Functor.Identity.Identity) @() @() $dApplicative)
      (modify'
         @Data.Functor.Identity.Identity
         @Int
         $dMonad
         (let {
            ds :: Int
            [LclId]
            ds = GHC.Types.I# 1# } in
          \ (ds :: Int) -> + @Int $dNum ds ds))
end Rec }




==================== Desugar (after optimization) ====================
Result size of Desugar (after optimization)
  = {terms: 22, types: 25, coercions: 0, joins: 0/1}

-- RHS size: {terms: 5, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 80 10}]
T18231.$trModule
  = GHC.Types.Module
      (GHC.Types.TrNameS "main"#) (GHC.Types.TrNameS "T18231"#)

-- RHS size: {terms: 15, types: 21, coercions: 0, joins: 0/1}
m :: State Int ()
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 180 0}]
m = $ @'GHC.Types.LiftedRep
      @(StateT Int Data.Functor.Identity.Identity ())
      @(StateT Int Data.Functor.Identity.Identity ())
      (forever
         @(StateT Int Data.Functor.Identity.Identity)
         @()
         @()
         (Control.Monad.Trans.State.Strict.$fApplicativeStateT
            @Data.Functor.Identity.Identity
            @Int
            Data.Functor.Identity.$fFunctorIdentity
            Data.Functor.Identity.$fMonadIdentity))
      (modify'
         @Data.Functor.Identity.Identity
         @Int
         Data.Functor.Identity.$fMonadIdentity
         (let {
            ds :: Int
            [LclId,
             Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                     WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
            ds = GHC.Types.I# 1# } in
          \ (ds :: Int) -> + @Int GHC.Num.$fNumInt ds ds))




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = InitialPhase [Gentle],
             inline,
             rules,
             eta-expand,
             no case-of-case}
Result size of Simplifier
  = {terms: 26, types: 16, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
a' [Occ=LoopBreaker]
  :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
a'
  = \ (eta2 :: Int) ->
      case eta2 of { GHC.Types.I# x ->
      a' (GHC.Types.I# (GHC.Prim.+# x 1#))
      }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Specialise ====================
Result size of Specialise
  = {terms: 26, types: 16, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
a' [Occ=LoopBreaker]
  :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
a'
  = \ (eta2 :: Int) ->
      case eta2 of { GHC.Types.I# x ->
      a' (GHC.Types.I# (GHC.Prim.+# x 1#))
      }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Levels added: ====================
<$trModule,<0,0>>
<$trModule,<0,0>> = "main"#
<$trModule,<0,0>>
<$trModule,<0,0>> = GHC.Types.TrNameS $trModule
<$trModule,<0,0>>
<$trModule,<0,0>> = "T18231"#
<$trModule,<0,0>>
<$trModule,<0,0>> = GHC.Types.TrNameS $trModule
<T18231.$trModule,<0,0>>
<T18231.$trModule,<0,0>> = GHC.Types.Module $trModule $trModule
<a',<0,0>>
<a',<0,0>>
  = \ <eta2,<1,0>> ->
      case eta2 of <wild,<1,2>> { GHC.Types.I# <x,<1,2>> ->
      let {
        <lvl,F<0,0>>
        <lvl,F<0,0>>
          = \ <x,<1,0>> -> a' (GHC.Types.I# (GHC.Prim.+# x 1#)) } in
      lvl x
      };
<T18231.m,<0,0>>
<T18231.m,<0,0>> = a' `cast` <Co:5>



==================== Float out(FOS {Lam = Just 0, Consts = True, OverSatApps = False}) ====================
Result size of Float out(FOS {Lam = Just 0,
                              Consts = True,
                              OverSatApps = False})
  = {terms: 30, types: 22, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
lvl :: GHC.Prim.Int# -> Data.Functor.Identity.Identity ((), Int)
[LclId, Arity=1, Str=<L,U>b, Cpr=b]
lvl
  = \ (x :: GHC.Prim.Int#) -> a' (GHC.Types.I# (GHC.Prim.+# x 1#))

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
a' [Occ=LoopBreaker]
  :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId, Arity=1, Str=<L,U>b, Cpr=b]
a' = \ (eta2 :: Int) -> case eta2 of { GHC.Types.I# x -> lvl x }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX, Arity=1, Str=<L,U>b, Cpr=b]
m = a' `cast` <Co:5>




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 2 [main],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 30, types: 22, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
lvl :: GHC.Prim.Int# -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
lvl
  = \ (x :: GHC.Prim.Int#) -> a' (GHC.Types.I# (GHC.Prim.+# x 1#))

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
a' [Occ=LoopBreaker]
  :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
a' = \ (eta2 :: Int) -> case eta2 of { GHC.Types.I# x -> lvl x }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 1 [main],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 30, types: 22, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
lvl :: GHC.Prim.Int# -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
lvl
  = \ (x :: GHC.Prim.Int#) -> a' (GHC.Types.I# (GHC.Prim.+# x 1#))

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
a' [Occ=LoopBreaker]
  :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
a' = \ (eta2 :: Int) -> case eta2 of { GHC.Types.I# x -> lvl x }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 0 [main],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 30, types: 22, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
lvl :: GHC.Prim.Int# -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
lvl
  = \ (x :: GHC.Prim.Int#) -> a' (GHC.Types.I# (GHC.Prim.+# x 1#))

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
a' [Occ=LoopBreaker]
  :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
a' = \ (eta2 :: Int) -> case eta2 of { GHC.Types.I# x -> lvl x }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Float inwards ====================
Result size of Float inwards
  = {terms: 30, types: 22, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
lvl :: GHC.Prim.Int# -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
lvl
  = \ (x :: GHC.Prim.Int#) -> a' (GHC.Types.I# (GHC.Prim.+# x 1#))

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
a' [Occ=LoopBreaker]
  :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
a' = \ (eta2 :: Int) -> case eta2 of { GHC.Types.I# x -> lvl x }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Called arity analysis ====================
Result size of Called arity analysis
  = {terms: 30, types: 22, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
lvl :: GHC.Prim.Int# -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 CallArity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
lvl
  = \ (x :: GHC.Prim.Int#) -> a' (GHC.Types.I# (GHC.Prim.+# x 1#))

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
a' [Occ=LoopBreaker]
  :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
a' = \ (eta2 :: Int) -> case eta2 of { GHC.Types.I# x -> lvl x }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [post-call-arity],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 30, types: 22, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
lvl :: GHC.Prim.Int# -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
lvl
  = \ (x :: GHC.Prim.Int#) -> a' (GHC.Types.I# (GHC.Prim.+# x 1#))

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
a' [Occ=LoopBreaker]
  :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
a' = \ (eta2 :: Int) -> case eta2 of { GHC.Types.I# x -> lvl x }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Demand analysis ====================
Result size of Demand analysis
  = {terms: 30, types: 22, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
lvl :: GHC.Prim.Int# -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<B,A>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
lvl
  = \ (x [Dmd=<B,A>] :: GHC.Prim.Int#) ->
      a' (GHC.Types.I# (GHC.Prim.+# x 1#))

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
a' [Occ=LoopBreaker]
  :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<B,1*H>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
a'
  = \ (eta2 [Dmd=<B,1*H>] :: Int) ->
      case eta2 of { GHC.Types.I# x [Dmd=<B,A>] -> lvl x }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<B,1*H>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Constructed Product Result analysis ====================
Result size of Constructed Product Result analysis
  = {terms: 30, types: 22, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
lvl :: GHC.Prim.Int# -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<B,A>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
lvl
  = \ (x [Dmd=<B,A>] :: GHC.Prim.Int#) ->
      a' (GHC.Types.I# (GHC.Prim.+# x 1#))

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
a' [Occ=LoopBreaker]
  :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<B,1*H>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
a'
  = \ (eta2 [Dmd=<B,1*H>] :: Int) ->
      case eta2 of { GHC.Types.I# x [Dmd=<B,A>] -> lvl x }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<B,1*H>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Worker Wrapper binds ====================
Result size of Worker Wrapper binds
  = {terms: 38, types: 30, coercions: 5, joins: 0/2}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/2}
$wlvl [InlPrag=NOUSERINLINE[2]]
  :: (# #) -> Data.Functor.Identity.Identity ((), Int)
[LclId, Arity=1, Str=<L,U>b]
$wlvl
  = \ (void :: (# #)) ->
      let {
        w [Dmd=<B,A>] :: GHC.Prim.Int#
        [LclId]
        w = 0# } in
      let {
        x [Dmd=<B,A>] :: GHC.Prim.Int#
        [LclId]
        x = w } in
      a' (GHC.Types.I# (GHC.Prim.+# x 1#))

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
lvl [InlPrag=NOUSERINLINE[2]]
  :: GHC.Prim.Int# -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<B,A>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)}]
lvl = \ (w [Dmd=<B,A>] :: GHC.Prim.Int#) -> $wlvl GHC.Prim.void#

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
a' [Occ=LoopBreaker]
  :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<B,H>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
a'
  = \ (eta2 [Dmd=<B,H>] :: Int) ->
      case eta2 of { GHC.Types.I# x [Dmd=<B,A>] -> lvl x }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<B,1*H>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [post-worker-wrapper],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 28, types: 22, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
$wlvl [InlPrag=NOUSERINLINE[2]]
  :: (# #) -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
$wlvl = \ _ [Occ=Dead] -> a' (GHC.Types.I# 1#)

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
a' [Occ=LoopBreaker]
  :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
a'
  = \ (eta2 :: Int) ->
      case eta2 of { GHC.Types.I# x [Dmd=<B,A>] -> $wlvl GHC.Prim.(##) }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Exitification transformation ====================
Result size of Exitification transformation
  = {terms: 28, types: 22, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
$wlvl [InlPrag=NOUSERINLINE[2]]
  :: (# #) -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
$wlvl = \ _ [Occ=Dead] -> a' (GHC.Types.I# 1#)

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
a' [Occ=LoopBreaker]
  :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
a'
  = \ (eta2 :: Int) ->
      case eta2 of { GHC.Types.I# x [Dmd=<B,A>] -> $wlvl GHC.Prim.(##) }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Levels added: ====================
<$trModule,<0,0>>
<$trModule,<0,0>> = "main"#
<$trModule,<0,0>>
<$trModule,<0,0>> = GHC.Types.TrNameS $trModule
<$trModule,<0,0>>
<$trModule,<0,0>> = "T18231"#
<$trModule,<0,0>>
<$trModule,<0,0>> = GHC.Types.TrNameS $trModule
<T18231.$trModule,<0,0>>
<T18231.$trModule,<0,0>> = GHC.Types.Module $trModule $trModule
<$wlvl,<0,0>>
<$wlvl,<0,0>>
  = \ <void,<1,0>> ->
      a'
        (let {
           <lvl,F<0,0>>
           <lvl,F<0,0>> = GHC.Types.I# 1# } in
         lvl);
<a',<0,0>>
<a',<0,0>>
  = \ <eta2,<1,0>> ->
      case eta2 of <wild,<1,2>> { GHC.Types.I# <x,<1,2>> ->
      let {
        <lvl,F<0,0>>
        <lvl,F<0,0>> = $wlvl GHC.Prim.(##) } in
      lvl
      };
<T18231.m,<0,0>>
<T18231.m,<0,0>> = a' `cast` <Co:5>



==================== Float out(FOS {Lam = Just 0, Consts = True, OverSatApps = True}) ====================
Result size of Float out(FOS {Lam = Just 0,
                              Consts = True,
                              OverSatApps = True})
  = {terms: 32, types: 27, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl :: Int
[LclId]
lvl = GHC.Types.I# 1#

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$wlvl [InlPrag=NOUSERINLINE[2]]
  :: (# #) -> Data.Functor.Identity.Identity ((), Int)
[LclId, Arity=1, Str=<L,U>b, Cpr=b]
$wlvl = \ _ [Occ=Dead] -> a' lvl

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl :: Data.Functor.Identity.Identity ((), Int)
[LclId, Str=b, Cpr=b]
lvl = $wlvl GHC.Prim.(##)

-- RHS size: {terms: 5, types: 3, coercions: 0, joins: 0/0}
a' [Occ=LoopBreaker]
  :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId, Arity=1, Str=<L,U>b, Cpr=b]
a'
  = \ (eta2 :: Int) ->
      case eta2 of { GHC.Types.I# x [Dmd=<B,A>] -> lvl }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Common sub-expression ====================
Result size of Common sub-expression
  = {terms: 32, types: 27, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl :: Int
[LclId]
lvl = GHC.Types.I# 1#

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$wlvl [InlPrag=NOUSERINLINE[2]]
  :: (# #) -> Data.Functor.Identity.Identity ((), Int)
[LclId, Arity=1, Str=<L,U>b, Cpr=b]
$wlvl = \ _ [Occ=Dead] -> a' lvl

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl :: Data.Functor.Identity.Identity ((), Int)
[LclId, Str=b, Cpr=b]
lvl = $wlvl GHC.Prim.(##)

-- RHS size: {terms: 5, types: 3, coercions: 0, joins: 0/0}
a' [Occ=LoopBreaker]
  :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId, Arity=1, Str=<L,U>b, Cpr=b]
a'
  = \ (eta2 :: Int) ->
      case eta2 of wild [Dmd=<B,A>] { GHC.Types.I# x [Dmd=<B,A>] -> lvl }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Float inwards ====================
Result size of Float inwards
  = {terms: 32, types: 27, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl :: Int
[LclId]
lvl = GHC.Types.I# 1#

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$wlvl [InlPrag=NOUSERINLINE[2]]
  :: (# #) -> Data.Functor.Identity.Identity ((), Int)
[LclId, Arity=1, Str=<L,U>b, Cpr=b]
$wlvl = \ _ [Occ=Dead] -> a' lvl

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl :: Data.Functor.Identity.Identity ((), Int)
[LclId, Str=b, Cpr=b]
lvl = $wlvl GHC.Prim.(##)

-- RHS size: {terms: 5, types: 3, coercions: 0, joins: 0/0}
a' [Occ=LoopBreaker]
  :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId, Arity=1, Str=<L,U>b, Cpr=b]
a'
  = \ (eta2 :: Int) ->
      case eta2 of wild [Dmd=<B,A>] { GHC.Types.I# x [Dmd=<B,A>] -> lvl }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [final],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 24, types: 20, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl [Occ=LoopBreaker] :: Data.Functor.Identity.Identity ((), Int)
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
lvl = lvl
end Rec }

-- RHS size: {terms: 5, types: 3, coercions: 0, joins: 0/0}
a' :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
a'
  = \ (eta2 :: Int) ->
      case eta2 of { GHC.Types.I# x [Dmd=<B,A>] -> lvl }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Liberate case ====================
Result size of Liberate case
  = {terms: 24, types: 20, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl [Occ=LoopBreaker] :: Data.Functor.Identity.Identity ((), Int)
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
lvl = lvl
end Rec }

-- RHS size: {terms: 5, types: 3, coercions: 0, joins: 0/0}
a' :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
a'
  = \ (eta2 :: Int) ->
      case eta2 of { GHC.Types.I# x [Dmd=<B,A>] -> lvl }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [post-liberate-case],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 24, types: 20, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl [Occ=LoopBreaker] :: Data.Functor.Identity.Identity ((), Int)
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
lvl = lvl
end Rec }

-- RHS size: {terms: 5, types: 3, coercions: 0, joins: 0/0}
a' :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
a'
  = \ (eta2 :: Int) ->
      case eta2 of { GHC.Types.I# x [Dmd=<B,A>] -> lvl }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== SpecConstr ====================
Result size of SpecConstr
  = {terms: 24, types: 20, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl [Occ=LoopBreaker] :: Data.Functor.Identity.Identity ((), Int)
[LclId, Str=b, Cpr=b]
lvl = lvl
end Rec }

-- RHS size: {terms: 5, types: 3, coercions: 0, joins: 0/0}
a' :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId, Arity=1, Str=<L,U>b, Cpr=b]
a'
  = \ (eta2 :: Int) ->
      case eta2 of { GHC.Types.I# x [Dmd=<B,A>] -> lvl }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [post-spec-constr],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 24, types: 20, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl [Occ=LoopBreaker] :: Data.Functor.Identity.Identity ((), Int)
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
lvl = lvl
end Rec }

-- RHS size: {terms: 5, types: 3, coercions: 0, joins: 0/0}
a' :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
a'
  = \ (eta2 :: Int) ->
      case eta2 of { GHC.Types.I# x [Dmd=<B,A>] -> lvl }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Common sub-expression ====================
Result size of Common sub-expression
  = {terms: 24, types: 20, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl [Occ=LoopBreaker] :: Data.Functor.Identity.Identity ((), Int)
[LclId, Str=b, Cpr=b]
lvl = lvl
end Rec }

-- RHS size: {terms: 5, types: 3, coercions: 0, joins: 0/0}
a' :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId, Arity=1, Str=<L,U>b, Cpr=b]
a'
  = \ (eta2 :: Int) ->
      case eta2 of wild [Dmd=<B,A>] { GHC.Types.I# x [Dmd=<B,A>] -> lvl }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [post-final-cse],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 24, types: 20, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl [Occ=LoopBreaker] :: Data.Functor.Identity.Identity ((), Int)
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
lvl = lvl
end Rec }

-- RHS size: {terms: 5, types: 3, coercions: 0, joins: 0/0}
a' :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
a'
  = \ (eta2 :: Int) ->
      case eta2 of { GHC.Types.I# x [Dmd=<B,A>] -> lvl }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Demand analysis ====================
Result size of Demand analysis
  = {terms: 24, types: 20, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
$trModule = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule = GHC.Types.Module $trModule $trModule

Rec {
-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl [Occ=LoopBreaker] :: Data.Functor.Identity.Identity ((), Int)
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
lvl = lvl
end Rec }

-- RHS size: {terms: 5, types: 3, coercions: 0, joins: 0/0}
a' :: Int -> Data.Functor.Identity.Identity ((), Int)
[LclId,
 Arity=1,
 Str=<B,1*H>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
a'
  = \ (eta2 [Dmd=<B,1*H>] :: Int) ->
      case eta2 of { GHC.Types.I# x [Dmd=<B,A>] -> lvl }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[LclIdX,
 Arity=1,
 Str=<B,1*H>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = a' `cast` <Co:5>




==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 24, types: 20, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
T18231.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule3 :: GHC.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule3 = GHC.Types.TrNameS T18231.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
T18231.$trModule2 = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule1 :: GHC.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule1 = GHC.Types.TrNameS T18231.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
T18231.$trModule
  = GHC.Types.Module T18231.$trModule3 T18231.$trModule1

Rec {
-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Data.Functor.Identity.Identity ((), Int)
[GblId, Str=b, Cpr=b]
lvl = lvl
end Rec }

-- RHS size: {terms: 5, types: 3, coercions: 0, joins: 0/0}
T18231.m1 :: Int -> Data.Functor.Identity.Identity ((), Int)
[GblId, Arity=1, Str=<B,1*H>b, Cpr=b, Unf=OtherCon []]
T18231.m1
  = \ (eta2 :: Int) -> case eta2 of { GHC.Types.I# x -> lvl }

-- RHS size: {terms: 1, types: 0, coercions: 5, joins: 0/0}
m :: State Int ()
[GblId,
 Arity=1,
 Str=<B,1*H>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
m = T18231.m1 `cast` <Co:5>




==================== CorePrep ====================
Result size of CorePrep
  = {terms: 26, types: 21, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule4 :: GHC.Prim.Addr#
[GblId, Unf=OtherCon []]
T18231.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule3 :: GHC.Types.TrName
[GblId, Unf=OtherCon []]
T18231.$trModule3 = GHC.Types.TrNameS T18231.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule2 :: GHC.Prim.Addr#
[GblId, Unf=OtherCon []]
T18231.$trModule2 = "T18231"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule1 :: GHC.Types.TrName
[GblId, Unf=OtherCon []]
T18231.$trModule1 = GHC.Types.TrNameS T18231.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
T18231.$trModule :: GHC.Types.Module
[GblId, Unf=OtherCon []]
T18231.$trModule
  = GHC.Types.Module T18231.$trModule3 T18231.$trModule1

Rec {
-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Data.Functor.Identity.Identity ((), GHC.Types.Int)
[GblId, Str=b, Cpr=b]
lvl = lvl
end Rec }

-- RHS size: {terms: 5, types: 3, coercions: 0, joins: 0/0}
T18231.m1
  :: GHC.Types.Int
     -> Data.Functor.Identity.Identity ((), GHC.Types.Int)
[GblId, Arity=1, Str=<B,1*H>b, Cpr=b, Unf=OtherCon []]
T18231.m1
  = \ (eta2 [Occ=Once1!] :: GHC.Types.Int) ->
      case eta2 of { GHC.Types.I# _ [Occ=Dead] -> lvl }

-- RHS size: {terms: 3, types: 1, coercions: 5, joins: 0/0}
T18231.m :: Control.Monad.Trans.State.Strict.State GHC.Types.Int ()
[GblId, Arity=1, Str=<B,1*H>b, Cpr=b, Unf=OtherCon []]
T18231.m
  = (\ (eta [Occ=Once1] :: GHC.Types.Int) -> T18231.m1 eta)
    `cast` <Co:5>



