[1 of 1] Compiling Foo              ( T13031.hs, T13031.o )

==================== Desugar (before optimization) ====================
Result size of Desugar (before optimization)
  = {terms: 23, types: 33, coercions: 0, joins: 0/1}

Rec {
-- RHS size: {terms: 5, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX]
Foo.$trModule
  = GHC.Types.Module
      (GHC.Types.TrNameS "main"#) (GHC.Types.TrNameS "Foo"#)

-- RHS size: {terms: 16, types: 22, coercions: 0, joins: 0/1}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX]
f = \ (@p) (@p) (@a) ->
      letrec {
        f :: Bool -> p -> p -> a
        [LclId]
        f = \ (ds :: Bool) ->
              case ds of wild {
                False ->
                  \ (p :: p) (q :: p) ->
                    raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False;
                True ->
                  raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True
              }; } in
      f
end Rec }




==================== Desugar (after optimization) ====================
Result size of Desugar (after optimization)
  = {terms: 21, types: 29, coercions: 0, joins: 0/0}

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [32] 44 60}]
f = \ (@p) (@p) (@a) (ds :: Bool) ->
      case ds of {
        False ->
          \ _ [Occ=Dead] _ [Occ=Dead] ->
            raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False;
        True ->
          raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True
      }

-- RHS size: {terms: 5, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 10}]
Foo.$trModule
  = GHC.Types.Module
      (GHC.Types.TrNameS "main"#) (GHC.Types.TrNameS "Foo"#)




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = InitialPhase [Gentle],
             inline,
             rules,
             eta-expand,
             no case-of-case}
Result size of Simplifier
  = {terms: 30, types: 36, coercions: 0, joins: 0/0}

-- RHS size: {terms: 15, types: 21, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<L,U><L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds :: Bool)
      (eta [OS=OneShot] :: p)
      (eta [OS=OneShot] :: p) ->
      case ds of {
        False -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False;
        True ->
          case raise#
                 @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True
          of wild {
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Specialise ====================
Result size of Specialise
  = {terms: 30, types: 36, coercions: 0, joins: 0/0}

-- RHS size: {terms: 15, types: 21, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<L,U><L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds :: Bool)
      (eta [OS=OneShot] :: p)
      (eta [OS=OneShot] :: p) ->
      case ds of {
        False -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False;
        True ->
          case raise#
                 @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True
          of wild {
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Levels added: ====================
<Foo.f,<0,0>>
<Foo.f,<0,0>>
  = \ <p,<1,0>>
      <p,<1,0>>
      <a,<1,0>>
      <ds,<1,0>>
      <eta,<1,0>>
      <eta,<1,0>> ->
      case ds of <wild,<1,2>> {
        GHC.Types.False ->
          let {
            <lvl,F<0,0>>
            <lvl,F<0,0>>
              = \ <a,<0,1>> ->
                  GHC.Prim.raise#
                    @GHC.Types.Bool @'GHC.Types.LiftedRep @a GHC.Types.False } in
          lvl @a;
        GHC.Types.True ->
          case let {
                 <lvl,F<0,0>>
                 <lvl,F<0,0>>
                   = \ <a,<0,1>> <p,<0,1>> <p,<0,1>> ->
                       GHC.Prim.raise#
                         @GHC.Types.Bool
                         @'GHC.Types.LiftedRep
                         @(p -> p -> a)
                         GHC.Types.True } in
               lvl @a @p @p
          of <wild,<1,3>> {
          }
      }
<$trModule,<0,0>>
<$trModule,<0,0>> = "main"#
<$trModule,<0,0>>
<$trModule,<0,0>> = GHC.Types.TrNameS $trModule
<$trModule,<0,0>>
<$trModule,<0,0>> = "Foo"#
<$trModule,<0,0>>
<$trModule,<0,0>> = GHC.Types.TrNameS $trModule
<Foo.$trModule,<0,0>>
<Foo.$trModule,<0,0>> = GHC.Types.Module $trModule $trModule



==================== Float out(FOS {Lam = Just 0, Consts = True, OverSatApps = False}) ====================
Result size of Float out(FOS {Lam = Just 0,
                              Consts = True,
                              OverSatApps = False})
  = {terms: 38, types: 60, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId, Str=b, Cpr=b]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId, Str=b, Cpr=b]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 17, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX, Arity=3, Str=<L,U><L,U><L,U>b, Cpr=b]
f = \ (@p)
      (@p)
      (@a)
      (ds :: Bool)
      (eta [OS=OneShot] :: p)
      (eta [OS=OneShot] :: p) ->
      case ds of {
        False -> lvl @a;
        True -> case lvl @a @p @p of wild { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 2 [main],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<L,U><L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds :: Bool)
      _ [Occ=Dead, OS=OneShot]
      _ [Occ=Dead, OS=OneShot] ->
      case ds of {
        False -> lvl @a;
        True -> case lvl of wild { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 1 [main],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<L,U><L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds :: Bool)
      _ [Occ=Dead, OS=OneShot]
      _ [Occ=Dead, OS=OneShot] ->
      case ds of {
        False -> lvl @a;
        True -> case lvl of wild { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 0 [main],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<L,U><L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds :: Bool)
      _ [Occ=Dead, OS=OneShot]
      _ [Occ=Dead, OS=OneShot] ->
      case ds of {
        False -> lvl @a;
        True -> case lvl of wild { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Float inwards ====================
Result size of Float inwards
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<L,U><L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds :: Bool)
      _ [Occ=Dead, OS=OneShot]
      _ [Occ=Dead, OS=OneShot] ->
      case ds of {
        False -> lvl @a;
        True -> case lvl of wild { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Called arity analysis ====================
Result size of Called arity analysis
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<L,U><L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds :: Bool)
      _ [Occ=Dead, OS=OneShot]
      _ [Occ=Dead, OS=OneShot] ->
      case ds of {
        False -> lvl @a;
        True -> case lvl of wild { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [post-call-arity],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<L,U><L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds :: Bool)
      _ [Occ=Dead, OS=OneShot]
      _ [Occ=Dead, OS=OneShot] ->
      case ds of {
        False -> lvl @a;
        True -> case lvl of wild { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Demand analysis ====================
Result size of Demand analysis
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<B,1*U><B,A><B,A>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds [Dmd=<B,1*U>] :: Bool)
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot]
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot] ->
      case ds of {
        False -> lvl @a;
        True -> case lvl of wild [Dmd=<B,A>] { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Constructed Product Result analysis ====================
Result size of Constructed Product Result analysis
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<B,1*U><B,A><B,A>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds [Dmd=<B,1*U>] :: Bool)
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot]
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot] ->
      case ds of {
        False -> lvl @a;
        True -> case lvl of wild [Dmd=<B,A>] { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Worker Wrapper binds ====================
Result size of Worker Wrapper binds
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<B,1*U><B,A><B,A>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds [Dmd=<B,U>] :: Bool)
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot]
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot] ->
      case ds of {
        False -> lvl @a;
        True -> case lvl of wild [Dmd=<B,A>] { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [post-worker-wrapper],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<L,U><L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds :: Bool)
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot]
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot] ->
      case ds of {
        False -> lvl @a;
        True -> case lvl of wild { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Exitification transformation ====================
Result size of Exitification transformation
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<L,U><L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds :: Bool)
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot]
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot] ->
      case ds of {
        False -> lvl @a;
        True -> case lvl of wild { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Levels added: ====================
<lvl,<0,0>>
<lvl,<0,0>>
  = \ <a,<0,1>> ->
      GHC.Prim.raise#
        @GHC.Types.Bool @'GHC.Types.LiftedRep @a GHC.Types.False
<lvl,<0,0>>
<lvl,<0,0>>
  = \ <a,<0,1>> <p,<0,1>> <p,<0,1>> ->
      GHC.Prim.raise#
        @GHC.Types.Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True
<Foo.f,<0,0>>
<Foo.f,<0,0>>
  = \ <p,<1,0>>
      <p,<1,0>>
      <a,<1,0>>
      <ds,<1,0>>
      <eta,<1,0>>
      <eta,<1,0>> ->
      case ds of <wild,<1,2>> {
        GHC.Types.False -> lvl @a;
        GHC.Types.True -> case lvl of <wild,<1,3>> { }
      }
<$trModule,<0,0>>
<$trModule,<0,0>> = "main"#
<$trModule,<0,0>>
<$trModule,<0,0>> = GHC.Types.TrNameS $trModule
<$trModule,<0,0>>
<$trModule,<0,0>> = "Foo"#
<$trModule,<0,0>>
<$trModule,<0,0>> = GHC.Types.TrNameS $trModule
<Foo.$trModule,<0,0>>
<Foo.$trModule,<0,0>> = GHC.Types.Module $trModule $trModule



==================== Float out(FOS {Lam = Just 0, Consts = True, OverSatApps = True}) ====================
Result size of Float out(FOS {Lam = Just 0,
                              Consts = True,
                              OverSatApps = True})
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId, Str=b, Cpr=b]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId, Str=b, Cpr=b]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<L,U><L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds :: Bool)
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot]
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot] ->
      case ds of {
        False -> lvl @a;
        True -> case lvl of wild { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Common sub-expression ====================
Result size of Common sub-expression
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId, Str=b, Cpr=b]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId, Str=b, Cpr=b]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<L,U><L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds :: Bool)
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot]
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot] ->
      case ds of wild [Dmd=<B,A>] {
        False -> lvl @a;
        True -> case lvl of wild { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Float inwards ====================
Result size of Float inwards
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId, Str=b, Cpr=b]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId, Str=b, Cpr=b]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<L,U><L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds :: Bool)
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot]
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot] ->
      case ds of wild [Dmd=<B,A>] {
        False -> lvl @a;
        True -> case lvl of wild { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [final],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<L,U><L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds :: Bool)
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot]
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot] ->
      case ds of {
        False -> lvl @a;
        True -> case lvl of wild { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Liberate case ====================
Result size of Liberate case
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<L,U><L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds :: Bool)
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot]
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot] ->
      case ds of {
        False -> lvl @a;
        True -> case lvl of wild { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [post-liberate-case],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<L,U><L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds :: Bool)
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot]
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot] ->
      case ds of {
        False -> lvl @a;
        True -> case lvl of wild { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== SpecConstr ====================
Result size of SpecConstr
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId, Str=b, Cpr=b]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId, Str=b, Cpr=b]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<L,U><L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds :: Bool)
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot]
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot] ->
      case ds of {
        False -> lvl @a;
        True -> case lvl of wild { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [post-spec-constr],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<L,U><L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds :: Bool)
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot]
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot] ->
      case ds of {
        False -> lvl @a;
        True -> case lvl of wild { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Common sub-expression ====================
Result size of Common sub-expression
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId, Str=b, Cpr=b]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId, Str=b, Cpr=b]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<L,U><L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds :: Bool)
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot]
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot] ->
      case ds of wild [Dmd=<B,A>] {
        False -> lvl @a;
        True -> case lvl of wild { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [post-final-cse],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<L,U><L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds :: Bool)
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot]
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot] ->
      case ds of {
        False -> lvl @a;
        True -> case lvl of wild { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Demand analysis ====================
Result size of Demand analysis
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
lvl :: forall {a}. a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl
  = \ (@a) (@p) (@p) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=3,
 Str=<B,1*U><B,A><B,A>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p)
      (@a)
      (ds [Dmd=<B,1*U>] :: Bool)
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot]
      _ [Occ=Dead, Dmd=<B,A>, OS=OneShot] ->
      case ds of {
        False -> lvl @a;
        True -> case lvl of wild [Dmd=<B,A>] { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule = GHC.Types.Module $trModule $trModule




==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Foo.f2 :: forall {a}. a
[GblId, Str=b, Cpr=b]
Foo.f2
  = \ (@a) -> raise# @Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Foo.f1 :: forall {a} {p1} {p2}. p2 -> p1 -> a
[GblId, Str=b, Cpr=b]
Foo.f1
  = \ (@a) (@p) (@p1) ->
      raise# @Bool @'GHC.Types.LiftedRep @(p1 -> p -> a) GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
f :: forall {p1} {p2} {a}. Bool -> p1 -> p2 -> a
[GblId,
 Arity=3,
 Str=<B,1*U><B,A><B,A>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
f = \ (@p)
      (@p1)
      (@a)
      (ds :: Bool)
      _ [Occ=Dead, OS=OneShot]
      _ [Occ=Dead, OS=OneShot] ->
      case ds of {
        False -> Foo.f2 @a;
        True -> case Foo.f1 of wild1 { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule4 :: Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Foo.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule3 :: GHC.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule3 = GHC.Types.TrNameS Foo.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule2 :: Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Foo.$trModule2 = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule1 :: GHC.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule1 = GHC.Types.TrNameS Foo.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Foo.$trModule = GHC.Types.Module Foo.$trModule3 Foo.$trModule1




==================== CorePrep ====================
Result size of CorePrep
  = {terms: 38, types: 63, coercions: 0, joins: 0/0}

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Foo.f2 :: forall {a}. a
[GblId, Str=b, Cpr=b]
Foo.f2
  = \ (@a) ->
      GHC.Prim.raise#
        @GHC.Types.Bool @'GHC.Types.LiftedRep @a GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Foo.f1 :: forall {a} {p1} {p2}. p2 -> p1 -> a
[GblId, Str=b, Cpr=b]
Foo.f1
  = \ (@a) (@p) (@p1) ->
      GHC.Prim.raise#
        @GHC.Types.Bool
        @'GHC.Types.LiftedRep
        @(p1 -> p -> a)
        GHC.Types.True

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
Foo.f :: forall {p1} {p2} {a}. GHC.Types.Bool -> p1 -> p2 -> a
[GblId, Arity=3, Str=<B,1*U><B,A><B,A>b, Cpr=b, Unf=OtherCon []]
Foo.f
  = \ (@p)
      (@p1)
      (@a)
      (ds [Occ=Once1!] :: GHC.Types.Bool)
      _ [Occ=Dead, OS=OneShot]
      _ [Occ=Dead, OS=OneShot] ->
      case ds of {
        GHC.Types.False -> Foo.f2 @a;
        GHC.Types.True -> case Foo.f1 of { }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule4 :: GHC.Prim.Addr#
[GblId, Unf=OtherCon []]
Foo.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule3 :: GHC.Types.TrName
[GblId, Unf=OtherCon []]
Foo.$trModule3 = GHC.Types.TrNameS Foo.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule2 :: GHC.Prim.Addr#
[GblId, Unf=OtherCon []]
Foo.$trModule2 = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule1 :: GHC.Types.TrName
[GblId, Unf=OtherCon []]
Foo.$trModule1 = GHC.Types.TrNameS Foo.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[GblId, Unf=OtherCon []]
Foo.$trModule = GHC.Types.Module Foo.$trModule3 Foo.$trModule1



