[1 of 1] Compiling Fac              ( Fac.hs, Fac.o )

==================== Desugar (before optimization) ====================
Result size of Desugar (before optimization)
  = {terms: 57, types: 46, coercions: 0, joins: 0/10}

Rec {
-- RHS size: {terms: 5, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX]
Fac.$trModule
  = GHC.Types.Module
      (GHC.Types.TrNameS "main"#) (GHC.Types.TrNameS "Fac"#)

-- RHS size: {terms: 50, types: 37, coercions: 0, joins: 0/10}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX]
fac
  = \ (@p) ($dEq :: Eq p) ($dNum :: Num p) ->
      let {
        $dNum :: Num p
        [LclId]
        $dNum = $dNum } in
      let {
        $dEq :: Eq p
        [LclId]
        $dEq = $dEq } in
      let {
        $dNum :: Num p
        [LclId]
        $dNum = $dNum } in
      let {
        $dNum :: Num p
        [LclId]
        $dNum = $dNum } in
      let {
        $dNum :: Num p
        [LclId]
        $dNum = $dNum } in
      let {
        $dNum :: Num p
        [LclId]
        $dNum = $dNum } in
      letrec {
        fac :: p -> p
        [LclId]
        fac
          = \ (ds :: p) ->
              let {
                fail :: (# #) -> p
                [LclId]
                fail
                  = \ (ds [OS=OneShot] :: (# #)) ->
                      Control.Exception.Base.patError
                        @'GHC.Types.LiftedRep @p "Fac.hs:(3,1)-(4,21)|function fac"# } in
              let {
                n :: p
                [LclId]
                n = ds } in
              let {
                fail :: (# #) -> p
                [LclId]
                fail
                  = \ (ds [OS=OneShot] :: (# #)) ->
                      * @p $dNum n (fac (- @p $dNum n (fromInteger @p $dNum 1))) } in
              case == @p $dEq ds (fromInteger @p $dNum 0) of wild {
                False -> fail GHC.Prim.void#;
                True -> fromInteger @p $dNum 1
              }; } in
      fac
end Rec }




==================== Desugar (after optimization) ====================
Result size of Desugar (after optimization)
  = {terms: 35, types: 25, coercions: 0, joins: 0/1}

-- RHS size: {terms: 28, types: 16, coercions: 0, joins: 0/1}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150] 570 0}]
fac
  = \ (@p) ($dEq :: Eq p) ($dNum :: Num p) ->
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 550 0}]
        fac
          = \ (ds :: p) ->
              case == @p $dEq ds (fromInteger @p $dNum 0) of {
                False ->
                  * @p $dNum ds (fac (- @p $dNum ds (fromInteger @p $dNum 1)));
                True -> fromInteger @p $dNum 1
              }; } in
      fac

-- RHS size: {terms: 5, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 10}]
Fac.$trModule
  = GHC.Types.Module
      (GHC.Types.TrNameS "main"#) (GHC.Types.TrNameS "Fac"#)




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = InitialPhase [Gentle],
             inline,
             rules,
             eta-expand,
             no case-of-case}
Result size of Simplifier
  = {terms: 45, types: 30, coercions: 0, joins: 0/1}

-- RHS size: {terms: 30, types: 17, coercions: 0, joins: 0/1}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150 0] 590 0}]
fac
  = \ (@p) ($dEq :: Eq p) ($dNum :: Num p) (eta :: p) ->
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId,
         Arity=1,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 550 0}]
        fac
          = \ (ds :: p) ->
              case == @p $dEq ds (fromInteger @p $dNum 0) of {
                False ->
                  * @p $dNum ds (fac (- @p $dNum ds (fromInteger @p $dNum 1)));
                True -> fromInteger @p $dNum 1
              }; } in
      fac eta

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Specialise ====================
Result size of Specialise
  = {terms: 45, types: 30, coercions: 0, joins: 0/1}

-- RHS size: {terms: 30, types: 17, coercions: 0, joins: 0/1}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150 0] 590 0}]
fac
  = \ (@p) ($dEq :: Eq p) ($dNum :: Num p) (eta :: p) ->
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId, Arity=1]
        fac
          = \ (ds :: p) ->
              case == @p $dEq ds (fromInteger @p $dNum 0) of {
                False ->
                  * @p $dNum ds (fac (- @p $dNum ds (fromInteger @p $dNum 1)));
                True -> fromInteger @p $dNum 1
              }; } in
      fac eta

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Levels added: ====================
<Fac.fac,<0,0>>
<Fac.fac,<0,0>>
  = \ <p,<1,0>> <$dEq,<1,0>> <$dNum,<1,0>> <eta,<1,0>> ->
      letrec {
        <fac,<1,2>>
        <fac,<1,2>>
          = \ <ds,<2,0>> ->
              case GHC.Classes.==
                     @p
                     $dEq
                     ds
                     (let {
                        <lvl,F<1,0>>
                        <lvl,F<1,0>>
                          = GHC.Num.fromInteger
                              @p
                              $dNum
                              (let {
                                 <lvl,F<0,0>>
                                 <lvl,F<0,0>> = 0 } in
                               lvl) } in
                      lvl)
              of <wild,<2,2>> {
                GHC.Types.False ->
                  GHC.Num.*
                    @p
                    $dNum
                    ds
                    (fac
                       (GHC.Num.-
                          @p
                          $dNum
                          ds
                          (let {
                             <lvl,F<1,0>>
                             <lvl,F<1,0>>
                               = GHC.Num.fromInteger
                                   @p
                                   $dNum
                                   (let {
                                      <lvl,F<0,0>>
                                      <lvl,F<0,0>> = 1 } in
                                    lvl) } in
                           lvl)));
                GHC.Types.True ->
                  let {
                    <lvl,F<1,0>>
                    <lvl,F<1,0>>
                      = GHC.Num.fromInteger
                          @p
                          $dNum
                          (let {
                             <lvl,F<0,0>>
                             <lvl,F<0,0>> = 1 } in
                           lvl) } in
                  lvl
              }; } in
      fac eta
<$trModule,<0,0>>
<$trModule,<0,0>> = "main"#
<$trModule,<0,0>>
<$trModule,<0,0>> = GHC.Types.TrNameS $trModule
<$trModule,<0,0>>
<$trModule,<0,0>> = "Fac"#
<$trModule,<0,0>>
<$trModule,<0,0>> = GHC.Types.TrNameS $trModule
<Fac.$trModule,<0,0>>
<Fac.$trModule,<0,0>> = GHC.Types.Module $trModule $trModule



==================== Float out(FOS {Lam = Just 0, Consts = True, OverSatApps = False}) ====================
Result size of Float out(FOS {Lam = Just 0,
                              Consts = True,
                              OverSatApps = False})
  = {terms: 57, types: 36, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId]
lvl = 0

-- RHS size: {terms: 36, types: 20, coercions: 0, joins: 0/4}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX, Arity=3]
fac
  = \ (@p) ($dEq :: Eq p) ($dNum :: Num p) (eta :: p) ->
      let {
        lvl :: p
        [LclId]
        lvl = fromInteger @p $dNum lvl } in
      let {
        lvl :: p
        [LclId]
        lvl = fromInteger @p $dNum lvl } in
      let {
        lvl :: p
        [LclId]
        lvl = fromInteger @p $dNum lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId, Arity=1]
        fac
          = \ (ds :: p) ->
              case == @p $dEq ds lvl of {
                False -> * @p $dNum ds (fac (- @p $dNum ds lvl));
                True -> lvl
              }; } in
      fac eta

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 2 [main],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 57, types: 36, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 0

-- RHS size: {terms: 36, types: 20, coercions: 0, joins: 0/4}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150 0] 320 0}]
fac
  = \ (@p) ($dEq :: Eq p) ($dNum :: Num p) (eta :: p) ->
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId,
         Arity=1,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 160 0}]
        fac
          = \ (ds :: p) ->
              case == @p $dEq ds lvl of {
                False -> * @p $dNum ds (fac (- @p $dNum ds lvl));
                True -> lvl
              }; } in
      fac eta

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 1 [main],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 57, types: 36, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 0

-- RHS size: {terms: 36, types: 20, coercions: 0, joins: 0/4}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150 0] 320 0}]
fac
  = \ (@p) ($dEq :: Eq p) ($dNum :: Num p) (eta :: p) ->
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId,
         Arity=1,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 160 0}]
        fac
          = \ (ds :: p) ->
              case == @p $dEq ds lvl of {
                False -> * @p $dNum ds (fac (- @p $dNum ds lvl));
                True -> lvl
              }; } in
      fac eta

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 0 [main],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 57, types: 36, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 0

-- RHS size: {terms: 36, types: 20, coercions: 0, joins: 0/4}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150 0] 320 0}]
fac
  = \ (@p) ($dEq :: Eq p) ($dNum :: Num p) (eta :: p) ->
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId,
         Arity=1,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 160 0}]
        fac
          = \ (ds :: p) ->
              case == @p $dEq ds lvl of {
                False -> * @p $dNum ds (fac (- @p $dNum ds lvl));
                True -> lvl
              }; } in
      fac eta

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Float inwards ====================
Result size of Float inwards
  = {terms: 57, types: 36, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 0

-- RHS size: {terms: 36, types: 20, coercions: 0, joins: 0/4}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150 0] 320 0}]
fac
  = \ (@p) ($dEq :: Eq p) ($dNum :: Num p) (eta :: p) ->
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId,
         Arity=1,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 160 0}]
        fac
          = \ (ds :: p) ->
              case == @p $dEq ds lvl of {
                False -> * @p $dNum ds (fac (- @p $dNum ds lvl));
                True -> lvl
              }; } in
      fac eta

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Called arity analysis ====================
Result size of Called arity analysis
  = {terms: 57, types: 36, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 0

-- RHS size: {terms: 36, types: 20, coercions: 0, joins: 0/4}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150 0] 320 0}]
fac
  = \ (@p) ($dEq :: Eq p) ($dNum :: Num p) (eta :: p) ->
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId,
         Arity=1,
         CallArity=1,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 160 0}]
        fac
          = \ (ds :: p) ->
              case == @p $dEq ds lvl of {
                False -> * @p $dNum ds (fac (- @p $dNum ds lvl));
                True -> lvl
              }; } in
      fac eta

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [post-call-arity],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 57, types: 36, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 0

-- RHS size: {terms: 36, types: 20, coercions: 0, joins: 0/4}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150 0] 320 0}]
fac
  = \ (@p) ($dEq :: Eq p) ($dNum :: Num p) (eta :: p) ->
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId,
         Arity=1,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 160 0}]
        fac
          = \ (ds :: p) ->
              case == @p $dEq ds lvl of {
                False -> * @p $dNum ds (fac (- @p $dNum ds lvl));
                True -> lvl
              }; } in
      fac eta

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Demand analysis ====================
Result size of Demand analysis
  = {terms: 57, types: 36, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 0

-- RHS size: {terms: 36, types: 20, coercions: 0, joins: 0/4}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150 0] 320 0}]
fac
  = \ (@p)
      ($dEq [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq p)
      ($dNum [Dmd=<L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))>] :: Num p)
      (eta :: p) ->
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId,
         Arity=1,
         Str=<L,U> {aPH-><S(C(C(S))L),U(C(C1(U)),A)>},
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 160 0}]
        fac
          = \ (ds :: p) ->
              case == @p $dEq ds lvl of {
                False -> * @p $dNum ds (fac (- @p $dNum ds lvl));
                True -> lvl
              }; } in
      fac eta

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Constructed Product Result analysis ====================
Result size of Constructed Product Result analysis
  = {terms: 57, types: 36, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 0

-- RHS size: {terms: 36, types: 20, coercions: 0, joins: 0/4}
fac :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 150 0] 320 0}]
fac
  = \ (@p)
      ($dEq [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq p)
      ($dNum [Dmd=<L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))>] :: Num p)
      (eta :: p) ->
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId,
         Arity=1,
         Str=<L,U> {aPH-><S(C(C(S))L),U(C(C1(U)),A)>},
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 160 0}]
        fac
          = \ (ds :: p) ->
              case == @p $dEq ds lvl of {
                False -> * @p $dNum ds (fac (- @p $dNum ds lvl));
                True -> lvl
              }; } in
      fac eta

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Worker Wrapper binds ====================
Result size of Worker Wrapper binds
  = {terms: 83, types: 79, coercions: 0, joins: 0/9}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 0

-- RHS size: {terms: 50, types: 38, coercions: 0, joins: 0/9}
$wfac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>]
$wfac
  = \ (@p)
      (ww [Dmd=<C(C(S)),C(C1(U))>] :: p -> p -> Bool)
      (w [Dmd=<L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))>] :: Num p)
      (w :: p) ->
      let {
        ww [Dmd=<L,A>] :: p -> p -> Bool
        [LclId, Str=b, Cpr=b]
        ww
          = Control.Exception.Base.absentError
              @(p -> p -> Bool) "ww p -> p -> Bool"# } in
      let {
        w [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq p
        [LclId]
        w = GHC.Classes.C:Eq @p ww ww } in
      let {
        @p
        p = TYPE: p } in
      let {
        $dEq [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq p
        [LclId]
        $dEq = w } in
      let {
        $dNum [Dmd=<L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))>] :: Num p
        [LclId]
        $dNum = w } in
      let {
        eta :: p
        [LclId]
        eta = w } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p $dNum lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId,
         Arity=1,
         Str=<L,U>,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 160 0}]
        fac
          = \ (ds :: p) ->
              case == @p $dEq ds lvl of {
                False -> * @p $dNum ds (fac (- @p $dNum ds lvl));
                True -> lvl
              }; } in
      fac eta

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p)
      (w [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq p)
      (w [Dmd=<L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))>] :: Num p)
      (w :: p) ->
      case w of ww
      { GHC.Classes.C:Eq ww [Dmd=<C(C(S)),C(C1(U))>] ww [Dmd=<L,A>] ->
      $wfac @p ww w w
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [post-worker-wrapper],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 68, types: 61, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 0

-- RHS size: {terms: 35, types: 20, coercions: 0, joins: 0/4}
$wfac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 150 0] 310 0}]
$wfac
  = \ (@p) (ww :: p -> p -> Bool) (w :: Num p) (w :: p) ->
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p w lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p w lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p w lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId,
         Arity=1,
         Str=<L,U>,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
        fac
          = \ (ds :: p) ->
              case ww ds lvl of {
                False -> * @p w ds (fac (- @p w ds lvl));
                True -> lvl
              }; } in
      fac w

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p) (w :: Eq p) (w :: Num p) (w :: p) ->
      case w of
      { GHC.Classes.C:Eq ww [Dmd=<C(C(S)),C(C1(U))>] ww [Dmd=<L,A>] ->
      $wfac @p ww w w
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Exitification transformation ====================
Result size of Exitification transformation
  = {terms: 68, types: 61, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 0

-- RHS size: {terms: 35, types: 20, coercions: 0, joins: 0/4}
$wfac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 150 0] 310 0}]
$wfac
  = \ (@p) (ww :: p -> p -> Bool) (w :: Num p) (w :: p) ->
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p w lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p w lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p w lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId,
         Arity=1,
         Str=<L,U>,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
        fac
          = \ (ds :: p) ->
              case ww ds lvl of {
                False -> * @p w ds (fac (- @p w ds lvl));
                True -> lvl
              }; } in
      fac w

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p) (w :: Eq p) (w :: Num p) (w :: p) ->
      case w of
      { GHC.Classes.C:Eq ww [Dmd=<C(C(S)),C(C1(U))>] ww [Dmd=<L,A>] ->
      $wfac @p ww w w
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Levels added: ====================
<lvl,<0,0>>
<lvl,<0,0>> = 1
<lvl,<0,0>>
<lvl,<0,0>> = 1
<lvl,<0,0>>
<lvl,<0,0>> = 0
<$wfac,<0,0>>
<$wfac,<0,0>>
  = \ <p,<1,0>> <ww,<1,0>> <w,<1,0>> <w,<1,0>> ->
      let {
        <lvl,<1,2>>
        <lvl,<1,2>> = GHC.Num.fromInteger @p w lvl } in
      let {
        <lvl,<1,3>>
        <lvl,<1,3>> = GHC.Num.fromInteger @p w lvl } in
      let {
        <lvl,<1,4>>
        <lvl,<1,4>> = GHC.Num.fromInteger @p w lvl } in
      letrec {
        <fac,<1,5>>
        <fac,<1,5>>
          = \ <ds,<2,0>> ->
              case ww ds lvl of <wild,<2,2>> {
                GHC.Types.False -> GHC.Num.* @p w ds (fac (GHC.Num.- @p w ds lvl));
                GHC.Types.True -> lvl
              }; } in
      fac w
<Fac.fac,<0,0>>
<Fac.fac,<0,0>>
  = \ <p,<1,0>> <w,<1,0>> <w,<1,0>> <w,<1,0>> ->
      case w of <ww,<1,2>> { GHC.Classes.C:Eq <ww,<1,2>> <ww,<1,2>> ->
      $wfac @p ww w w
      }
<$trModule,<0,0>>
<$trModule,<0,0>> = "main"#
<$trModule,<0,0>>
<$trModule,<0,0>> = GHC.Types.TrNameS $trModule
<$trModule,<0,0>>
<$trModule,<0,0>> = "Fac"#
<$trModule,<0,0>>
<$trModule,<0,0>> = GHC.Types.TrNameS $trModule
<Fac.$trModule,<0,0>>
<Fac.$trModule,<0,0>> = GHC.Types.Module $trModule $trModule



==================== Float out(FOS {Lam = Just 0, Consts = True, OverSatApps = True}) ====================
Result size of Float out(FOS {Lam = Just 0,
                              Consts = True,
                              OverSatApps = True})
  = {terms: 68, types: 61, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId]
lvl = 0

-- RHS size: {terms: 35, types: 20, coercions: 0, joins: 0/4}
$wfac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>]
$wfac
  = \ (@p) (ww :: p -> p -> Bool) (w :: Num p) (w :: p) ->
      let {
        lvl :: p
        [LclId]
        lvl = fromInteger @p w lvl } in
      let {
        lvl :: p
        [LclId]
        lvl = fromInteger @p w lvl } in
      let {
        lvl :: p
        [LclId]
        lvl = fromInteger @p w lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId, Arity=1, Str=<L,U>]
        fac
          = \ (ds :: p) ->
              case ww ds lvl of {
                False -> * @p w ds (fac (- @p w ds lvl));
                True -> lvl
              }; } in
      fac w

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p) (w :: Eq p) (w :: Num p) (w :: p) ->
      case w of
      { GHC.Classes.C:Eq ww [Dmd=<C(C(S)),C(C1(U))>] ww [Dmd=<L,A>] ->
      $wfac @p ww w w
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Common sub-expression ====================
Result size of Common sub-expression
  = {terms: 66, types: 60, coercions: 0, joins: 0/4}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId]
lvl = lvl

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId]
lvl = 0

-- RHS size: {terms: 33, types: 19, coercions: 0, joins: 0/4}
$wfac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>]
$wfac
  = \ (@p) (ww :: p -> p -> Bool) (w :: Num p) (w :: p) ->
      let {
        lvl :: p
        [LclId]
        lvl = fromInteger @p w lvl } in
      let {
        lvl :: p
        [LclId]
        lvl = fromInteger @p w lvl } in
      let {
        lvl :: p
        [LclId]
        lvl = lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId, Arity=1, Str=<L,U>]
        fac
          = \ (ds :: p) ->
              case ww ds lvl of wild {
                False -> * @p w ds (fac (- @p w ds lvl));
                True -> lvl
              }; } in
      fac w

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p) (w :: Eq p) (w :: Num p) (w :: p) ->
      case w of ww
      { GHC.Classes.C:Eq ww [Dmd=<C(C(S)),C(C1(U))>] ww [Dmd=<L,A>] ->
      $wfac @p ww w w
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Float inwards ====================
Result size of Float inwards
  = {terms: 64, types: 59, coercions: 0, joins: 0/3}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId]
lvl = lvl

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId]
lvl = 0

-- RHS size: {terms: 31, types: 18, coercions: 0, joins: 0/3}
$wfac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>]
$wfac
  = \ (@p) (ww :: p -> p -> Bool) (w :: Num p) (w :: p) ->
      let {
        lvl :: p
        [LclId]
        lvl = fromInteger @p w lvl } in
      let {
        lvl :: p
        [LclId]
        lvl = fromInteger @p w lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId, Arity=1, Str=<L,U>]
        fac
          = \ (ds :: p) ->
              case ww ds lvl of wild {
                False -> * @p w ds (fac (- @p w ds lvl));
                True -> lvl
              }; } in
      fac w

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p) (w :: Eq p) (w :: Num p) (w :: p) ->
      case w of ww
      { GHC.Classes.C:Eq ww [Dmd=<C(C(S)),C(C1(U))>] ww [Dmd=<L,A>] ->
      $wfac @p ww w w
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [final],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 62, types: 58, coercions: 0, joins: 0/3}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 0

-- RHS size: {terms: 31, types: 18, coercions: 0, joins: 0/3}
$wfac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 120 0] 270 0}]
$wfac
  = \ (@p) (ww :: p -> p -> Bool) (w :: Num p) (w :: p) ->
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p w lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p w lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId,
         Arity=1,
         Str=<L,U>,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
        fac
          = \ (ds :: p) ->
              case ww ds lvl of {
                False -> * @p w ds (fac (- @p w ds lvl));
                True -> lvl
              }; } in
      fac w

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p) (w :: Eq p) (w :: Num p) (w :: p) ->
      case w of
      { GHC.Classes.C:Eq ww [Dmd=<C(C(S)),C(C1(U))>] ww [Dmd=<L,A>] ->
      $wfac @p ww w w
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Liberate case ====================
Result size of Liberate case
  = {terms: 62, types: 58, coercions: 0, joins: 0/3}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 0

-- RHS size: {terms: 31, types: 18, coercions: 0, joins: 0/3}
$wfac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 120 0] 270 0}]
$wfac
  = \ (@p) (ww :: p -> p -> Bool) (w :: Num p) (w :: p) ->
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p w lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p w lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId,
         Arity=1,
         Str=<L,U>,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
        fac
          = \ (ds :: p) ->
              case ww ds lvl of {
                False -> * @p w ds (fac (- @p w ds lvl));
                True -> lvl
              }; } in
      fac w

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p) (w :: Eq p) (w :: Num p) (w :: p) ->
      case w of
      { GHC.Classes.C:Eq ww [Dmd=<C(C(S)),C(C1(U))>] ww [Dmd=<L,A>] ->
      $wfac @p ww w w
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [post-liberate-case],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 62, types: 58, coercions: 0, joins: 0/3}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 0

-- RHS size: {terms: 31, types: 18, coercions: 0, joins: 0/3}
$wfac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 120 0] 270 0}]
$wfac
  = \ (@p) (ww :: p -> p -> Bool) (w :: Num p) (w :: p) ->
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p w lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p w lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId,
         Arity=1,
         Str=<L,U>,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
        fac
          = \ (ds :: p) ->
              case ww ds lvl of {
                False -> * @p w ds (fac (- @p w ds lvl));
                True -> lvl
              }; } in
      fac w

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p) (w :: Eq p) (w :: Num p) (w :: p) ->
      case w of
      { GHC.Classes.C:Eq ww [Dmd=<C(C(S)),C(C1(U))>] ww [Dmd=<L,A>] ->
      $wfac @p ww w w
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== SpecConstr ====================
Result size of SpecConstr
  = {terms: 62, types: 58, coercions: 0, joins: 0/3}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId]
lvl = 0

-- RHS size: {terms: 31, types: 18, coercions: 0, joins: 0/3}
$wfac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>]
$wfac
  = \ (@p) (ww :: p -> p -> Bool) (w :: Num p) (w :: p) ->
      let {
        lvl :: p
        [LclId]
        lvl = fromInteger @p w lvl } in
      let {
        lvl :: p
        [LclId]
        lvl = fromInteger @p w lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId, Arity=1, Str=<L,U>]
        fac
          = \ (ds :: p) ->
              case ww ds lvl of {
                False -> * @p w ds (fac (- @p w ds lvl));
                True -> lvl
              }; } in
      fac w

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p) (w :: Eq p) (w :: Num p) (w :: p) ->
      case w of
      { GHC.Classes.C:Eq ww [Dmd=<C(C(S)),C(C1(U))>] ww [Dmd=<L,A>] ->
      $wfac @p ww w w
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [post-spec-constr],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 62, types: 58, coercions: 0, joins: 0/3}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 0

-- RHS size: {terms: 31, types: 18, coercions: 0, joins: 0/3}
$wfac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 120 0] 270 0}]
$wfac
  = \ (@p) (ww :: p -> p -> Bool) (w :: Num p) (w :: p) ->
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p w lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p w lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId,
         Arity=1,
         Str=<L,U>,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
        fac
          = \ (ds :: p) ->
              case ww ds lvl of {
                False -> * @p w ds (fac (- @p w ds lvl));
                True -> lvl
              }; } in
      fac w

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p) (w :: Eq p) (w :: Num p) (w :: p) ->
      case w of
      { GHC.Classes.C:Eq ww [Dmd=<C(C(S)),C(C1(U))>] ww [Dmd=<L,A>] ->
      $wfac @p ww w w
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Common sub-expression ====================
Result size of Common sub-expression
  = {terms: 62, types: 58, coercions: 0, joins: 0/3}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId]
lvl = 0

-- RHS size: {terms: 31, types: 18, coercions: 0, joins: 0/3}
$wfac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>]
$wfac
  = \ (@p) (ww :: p -> p -> Bool) (w :: Num p) (w :: p) ->
      let {
        lvl :: p
        [LclId]
        lvl = fromInteger @p w lvl } in
      let {
        lvl :: p
        [LclId]
        lvl = fromInteger @p w lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId, Arity=1, Str=<L,U>]
        fac
          = \ (ds :: p) ->
              case ww ds lvl of wild {
                False -> * @p w ds (fac (- @p w ds lvl));
                True -> lvl
              }; } in
      fac w

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p) (w :: Eq p) (w :: Num p) (w :: p) ->
      case w of ww
      { GHC.Classes.C:Eq ww [Dmd=<C(C(S)),C(C1(U))>] ww [Dmd=<L,A>] ->
      $wfac @p ww w w
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = FinalPhase [post-final-cse],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 62, types: 58, coercions: 0, joins: 0/3}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 0

-- RHS size: {terms: 31, types: 18, coercions: 0, joins: 0/3}
$wfac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 120 0] 270 0}]
$wfac
  = \ (@p) (ww :: p -> p -> Bool) (w :: Num p) (w :: p) ->
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p w lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p w lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId,
         Arity=1,
         Str=<L,U>,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
        fac
          = \ (ds :: p) ->
              case ww ds lvl of {
                False -> * @p w ds (fac (- @p w ds lvl));
                True -> lvl
              }; } in
      fac w

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p) (w :: Eq p) (w :: Num p) (w :: p) ->
      case w of
      { GHC.Classes.C:Eq ww [Dmd=<C(C(S)),C(C1(U))>] ww [Dmd=<L,A>] ->
      $wfac @p ww w w
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Demand analysis ====================
Result size of Demand analysis
  = {terms: 62, types: 58, coercions: 0, joins: 0/3}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl = 0

-- RHS size: {terms: 31, types: 18, coercions: 0, joins: 0/3}
$wfac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[LclId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 120 0] 270 0}]
$wfac
  = \ (@p)
      (ww [Dmd=<C(C(S)),C(C1(U))>] :: p -> p -> Bool)
      (w [Dmd=<L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))>] :: Num p)
      (w :: p) ->
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p w lvl } in
      let {
        lvl :: p
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                 WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
        lvl = fromInteger @p w lvl } in
      letrec {
        fac [Occ=LoopBreaker] :: p -> p
        [LclId,
         Arity=1,
         Str=<L,U> {sQJ-><C(C(S)),C(C1(U))>},
         Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
        fac
          = \ (ds :: p) ->
              case ww ds lvl of {
                False -> * @p w ds (fac (- @p w ds lvl));
                True -> lvl
              }; } in
      fac w

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[LclIdX,
 Arity=3,
 Str=<S(C(C(S))L),1*U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p)
      (w [Dmd=<S(C(C(S))L),1*U(C(C1(U)),A)>] :: Eq p)
      (w [Dmd=<L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))>] :: Num p)
      (w :: p) ->
      case w of
      { GHC.Classes.C:Eq ww [Dmd=<C(C(S)),C(C1(U))>] ww [Dmd=<L,A>] ->
      $wfac @p ww w w
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Prim.Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
$trModule = GHC.Types.TrNameS $trModule

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module $trModule $trModule




==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 62, types: 58, coercions: 0, joins: 0/3}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Fac.fac2 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Fac.fac2 = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Fac.fac1 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Fac.fac1 = 0

-- RHS size: {terms: 31, types: 18, coercions: 0, joins: 0/3}
Fac.$wfac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (p -> p -> Bool) -> Num p => p -> p
[GblId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 120 0] 270 0}]
Fac.$wfac
  = \ (@p) (ww :: p -> p -> Bool) (w :: Num p) (w1 :: p) ->
      let {
        lvl :: p
        [LclId]
        lvl = fromInteger @p w Fac.fac2 } in
      let {
        lvl1 :: p
        [LclId]
        lvl1 = fromInteger @p w Fac.fac1 } in
      letrec {
        fac3 [Occ=LoopBreaker] :: p -> p
        [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
        fac3
          = \ (ds :: p) ->
              case ww ds lvl1 of {
                False -> * @p w ds (fac3 (- @p w ds lvl));
                True -> lvl
              }; } in
      fac3 w1

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (Eq p, Num p) => p -> p
[GblId,
 Arity=3,
 Str=<S(C(C(S))L),1*U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)}]
fac
  = \ (@p) (w :: Eq p) (w1 :: Num p) (w2 :: p) ->
      case w of { GHC.Classes.C:Eq ww1 ww2 -> Fac.$wfac @p ww1 w1 w2 }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Fac.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule3 :: GHC.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule3 = GHC.Types.TrNameS Fac.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Fac.$trModule2 = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule1 :: GHC.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule1 = GHC.Types.TrNameS Fac.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Fac.$trModule = GHC.Types.Module Fac.$trModule3 Fac.$trModule1




==================== CorePrep ====================
Result size of CorePrep
  = {terms: 68, types: 60, coercions: 0, joins: 0/5}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Fac.fac2 :: GHC.Num.Integer.Integer
[GblId, Unf=OtherCon []]
Fac.fac2 = GHC.Num.Integer.IS 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Fac.fac1 :: GHC.Num.Integer.Integer
[GblId, Unf=OtherCon []]
Fac.fac1 = GHC.Num.Integer.IS 0#

-- RHS size: {terms: 35, types: 20, coercions: 0, joins: 0/5}
Fac.$wfac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}.
     (p -> p -> GHC.Types.Bool) -> GHC.Num.Num p => p -> p
[GblId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=OtherCon []]
Fac.$wfac
  = \ (@p)
      (ww [Occ=OnceL1!] :: p -> p -> GHC.Types.Bool)
      (w :: GHC.Num.Num p)
      (w1 [Occ=Once1] :: p) ->
      let {
        lvl [Occ=OnceL2] :: p
        [LclId]
        lvl = GHC.Num.fromInteger @p w Fac.fac2 } in
      let {
        lvl1 [Occ=OnceL1] :: p
        [LclId]
        lvl1 = GHC.Num.fromInteger @p w Fac.fac1 } in
      letrec {
        fac3 [Occ=LoopBreaker] :: p -> p
        [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
        fac3
          = \ (ds :: p) ->
              case ww ds lvl1 of {
                GHC.Types.False ->
                  let {
                    sat [Occ=Once1] :: p
                    [LclId]
                    sat
                      = let {
                          sat [Occ=Once1] :: p
                          [LclId]
                          sat = GHC.Num.- @p w ds lvl } in
                        fac3 sat } in
                  GHC.Num.* @p w ds sat;
                GHC.Types.True -> lvl
              }; } in
      fac3 w1

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
Fac.fac [InlPrag=NOUSERINLINE[2]]
  :: forall {p}. (GHC.Classes.Eq p, GHC.Num.Num p) => p -> p
[GblId,
 Arity=3,
 Str=<S(C(C(S))L),1*U(C(C1(U)),A)><L,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><L,U>,
 Unf=OtherCon []]
Fac.fac
  = \ (@p)
      (w [Occ=Once1!] :: GHC.Classes.Eq p)
      (w1 [Occ=Once1] :: GHC.Num.Num p)
      (w2 [Occ=Once1] :: p) ->
      case w of { GHC.Classes.C:Eq ww1 [Occ=Once1] _ [Occ=Dead] ->
      Fac.$wfac @p ww1 w1 w2
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule4 :: GHC.Prim.Addr#
[GblId, Unf=OtherCon []]
Fac.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule3 :: GHC.Types.TrName
[GblId, Unf=OtherCon []]
Fac.$trModule3 = GHC.Types.TrNameS Fac.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule2 :: GHC.Prim.Addr#
[GblId, Unf=OtherCon []]
Fac.$trModule2 = "Fac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule1 :: GHC.Types.TrName
[GblId, Unf=OtherCon []]
Fac.$trModule1 = GHC.Types.TrNameS Fac.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Fac.$trModule :: GHC.Types.Module
[GblId, Unf=OtherCon []]
Fac.$trModule = GHC.Types.Module Fac.$trModule3 Fac.$trModule1



