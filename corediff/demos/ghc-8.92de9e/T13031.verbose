[1 of 1] Compiling Foo              ( T13031.hs, T13031.o )

==================== Desugar (before optimization) ====================
Result size of Desugar (before optimization)
  = {terms: 23, types: 33, coercions: 0, joins: 0/1}

Rec {
-- RHS size: {terms: 5, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX]
Foo.$trModule
  = GHC.Types.Module
      (GHC.Types.TrNameS "main"#) (GHC.Types.TrNameS "Foo"#)

-- RHS size: {terms: 16, types: 22, coercions: 0, joins: 0/1}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX]
f = \ (@p_atN) (@p_atP) (@a_atS) ->
      letrec {
        f_atV :: Bool -> p_atN -> p_atP -> a_atS
        [LclId]
        f_atV
          = \ (ds_duk :: Bool) ->
              case ds_duk of wild_00 {
                False ->
                  \ (p_atx :: p_atN) (q_aty :: p_atP) ->
                    raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False;
                True ->
                  raise#
                    @Bool
                    @'GHC.Types.LiftedRep
                    @(p_atN -> p_atP -> a_atS)
                    GHC.Types.True
              }; } in
      f_atV
end Rec }




==================== Desugar (after optimization) ====================
Result size of Desugar (after optimization)
  = {terms: 21, types: 29, coercions: 0, joins: 0/0}

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [32] 44 60}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk :: Bool) ->
      case ds_duk of {
        False ->
          \ _ [Occ=Dead] _ [Occ=Dead] ->
            raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False;
        True ->
          raise#
            @Bool
            @'GHC.Types.LiftedRep
            @(p_atN -> p_atP -> a_atS)
            GHC.Types.True
      }

-- RHS size: {terms: 5, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 30}]
Foo.$trModule
  = GHC.Types.Module
      (GHC.Types.TrNameS "main"#) (GHC.Types.TrNameS "Foo"#)




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = InitialPhase [Gentle],
             inline,
             rules,
             eta-expand,
             no case-of-case}
Result size of Simplifier
  = {terms: 29, types: 33, coercions: 0, joins: 0/0}

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [32] 44 60}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk :: Bool) ->
      case ds_duk of {
        False ->
          \ _ [Occ=Dead] _ [Occ=Dead] ->
            raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False;
        True ->
          raise#
            @Bool
            @'GHC.Types.LiftedRep
            @(p_atN -> p_atP -> a_atS)
            GHC.Types.True
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Specialise ====================
Result size of Specialise
  = {terms: 29, types: 33, coercions: 0, joins: 0/0}

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [32] 44 60}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk :: Bool) ->
      case ds_duk of {
        False ->
          \ _ [Occ=Dead] _ [Occ=Dead] ->
            raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False;
        True ->
          raise#
            @Bool
            @'GHC.Types.LiftedRep
            @(p_atN -> p_atP -> a_atS)
            GHC.Types.True
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Levels added: ====================
<Foo.f,<0,0>>
<Foo.f,<0,0>>
  = \ <p_atN,<1,0>> <p_atP,<1,0>> <a_atS,<1,0>> <ds_duk,<1,0>> ->
      case ds_duk of <wild_X1,<1,2>> {
        GHC.Types.False ->
          let {
            <lvl_suv,F<0,0>>
            <lvl_suv,F<0,0>>
              = \ <p_atN,<1,0>>
                  <a_atS,<1,0>>
                  <p_atP,<1,0>>
                  <p_atx,<1,0>>
                  <q_aty,<1,0>> ->
                  GHC.Prim.raise#
                    @GHC.Types.Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False } in
          lvl_suv @p_atN @a_atS @p_atP;
        GHC.Types.True ->
          let {
            <lvl_suw,F<0,0>>
            <lvl_suw,F<0,0>>
              = \ <a_atS,<0,1>> <p_atP,<0,1>> <p_atN,<0,1>> ->
                  GHC.Prim.raise#
                    @GHC.Types.Bool
                    @'GHC.Types.LiftedRep
                    @(p_atN -> p_atP -> a_atS)
                    GHC.Types.True } in
          lvl_suw @a_atS @p_atP @p_atN
      }
<$trModule_sup,<0,0>>
<$trModule_sup,<0,0>> = "main"#
<$trModule_suq,<0,0>>
<$trModule_suq,<0,0>> = GHC.Types.TrNameS $trModule_sup
<$trModule_sur,<0,0>>
<$trModule_sur,<0,0>> = "Foo"#
<$trModule_sus,<0,0>>
<$trModule_sus,<0,0>> = GHC.Types.TrNameS $trModule_sur
<Foo.$trModule,<0,0>>
<Foo.$trModule,<0,0>>
  = GHC.Types.Module $trModule_suq $trModule_sus



==================== Float out(FOS {Lam = Just 0, Consts = True, OverSatApps = False}) ====================
Result size of Float out(FOS {Lam = Just 0,
                              Consts = True,
                              OverSatApps = False})
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
lvl_suv :: forall {p} {a} {p}. p -> p -> a
[LclId, Arity=2, Str=<L,U><L,U>b, Cpr=b]
lvl_suv
  = \ (@p_atN) (@a_atS) (@p_atP) _ [Occ=Dead] _ [Occ=Dead] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl_suw :: forall {a} {p} {p}. p -> p -> a
[LclId, Str=b, Cpr=b]
lvl_suw
  = \ (@a_atS) (@p_atP) (@p_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX, Arity=1]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk :: Bool) ->
      case ds_duk of {
        False -> lvl_suv @p_atN @a_atS @p_atP;
        True -> lvl_suw @a_atS @p_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 2 [main],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
lvl_suv :: forall {p} {a} {p}. p -> p -> a
[LclId,
 Arity=2,
 Str=<L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
lvl_suv
  = \ (@p_atN) (@a_atS) (@p_atP) _ [Occ=Dead] _ [Occ=Dead] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl_suw :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl_suw
  = \ (@a_atS) (@p_atP) (@p_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk :: Bool) ->
      case ds_duk of {
        False -> lvl_suv @p_atN @a_atS @p_atP;
        True -> lvl_suw @a_atS @p_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 1 [main],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
lvl_suv :: forall {p} {a} {p}. p -> p -> a
[LclId,
 Arity=2,
 Str=<L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
lvl_suv
  = \ (@p_atN) (@a_atS) (@p_atP) _ [Occ=Dead] _ [Occ=Dead] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl_suw :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl_suw
  = \ (@a_atS) (@p_atP) (@p_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk :: Bool) ->
      case ds_duk of {
        False -> lvl_suv @p_atN @a_atS @p_atP;
        True -> lvl_suw @a_atS @p_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 0 [main],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
lvl_suv :: forall {p} {a} {p}. p -> p -> a
[LclId,
 Arity=2,
 Str=<L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
lvl_suv
  = \ (@p_atN) (@a_atS) (@p_atP) _ [Occ=Dead] _ [Occ=Dead] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl_suw :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl_suw
  = \ (@a_atS) (@p_atP) (@p_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk :: Bool) ->
      case ds_duk of {
        False -> lvl_suv @p_atN @a_atS @p_atP;
        True -> lvl_suw @a_atS @p_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Float inwards ====================
Result size of Float inwards
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
lvl_suv :: forall {p} {a} {p}. p -> p -> a
[LclId,
 Arity=2,
 Str=<L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
lvl_suv
  = \ (@p_atN) (@a_atS) (@p_atP) _ [Occ=Dead] _ [Occ=Dead] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl_suw :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl_suw
  = \ (@a_atS) (@p_atP) (@p_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk :: Bool) ->
      case ds_duk of {
        False -> lvl_suv @p_atN @a_atS @p_atP;
        True -> lvl_suw @a_atS @p_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Called arity analysis ====================
Result size of Called arity analysis
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
lvl_suv :: forall {p} {a} {p}. p -> p -> a
[LclId,
 Arity=2,
 Str=<L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
lvl_suv
  = \ (@p_atN) (@a_atS) (@p_atP) _ [Occ=Dead] _ [Occ=Dead] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl_suw :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl_suw
  = \ (@a_atS) (@p_atP) (@p_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk :: Bool) ->
      case ds_duk of {
        False -> lvl_suv @p_atN @a_atS @p_atP;
        True -> lvl_suw @a_atS @p_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 0 [post-call-arity],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
lvl_suv :: forall {p} {a} {p}. p -> p -> a
[LclId,
 Arity=2,
 Str=<L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
lvl_suv
  = \ (@p_atN) (@a_atS) (@p_atP) _ [Occ=Dead] _ [Occ=Dead] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl_suw :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl_suw
  = \ (@a_atS) (@p_atP) (@p_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk :: Bool) ->
      case ds_duk of {
        False -> lvl_suv @p_atN @a_atS @p_atP;
        True -> lvl_suw @a_atS @p_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Demand analysis ====================
Result size of Demand analysis
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
lvl_suv :: forall {p} {a} {p}. p -> p -> a
[LclId,
 Arity=2,
 Str=<B,A><B,A>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
lvl_suv
  = \ (@p_atN)
      (@a_atS)
      (@p_atP)
      _ [Occ=Dead, Dmd=<B,A>]
      _ [Occ=Dead, Dmd=<B,A>] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl_suw :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl_suw
  = \ (@a_atS) (@p_atP) (@p_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk [Dmd=<S,1*U>] :: Bool) ->
      case ds_duk of {
        False -> lvl_suv @p_atN @a_atS @p_atP;
        True -> lvl_suw @a_atS @p_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Constructed Product Result analysis ====================
Result size of Constructed Product Result analysis
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
lvl_suv :: forall {p} {a} {p}. p -> p -> a
[LclId,
 Arity=2,
 Str=<B,A><B,A>b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
lvl_suv
  = \ (@p_atN)
      (@a_atS)
      (@p_atP)
      _ [Occ=Dead, Dmd=<B,A>]
      _ [Occ=Dead, Dmd=<B,A>] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl_suw :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl_suw
  = \ (@a_atS) (@p_atP) (@p_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk [Dmd=<S,1*U>] :: Bool) ->
      case ds_duk of {
        False -> lvl_suv @p_atN @a_atS @p_atP;
        True -> lvl_suw @a_atS @p_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Worker Wrapper binds ====================
Result size of Worker Wrapper binds
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
lvl_suv :: forall {p} {a} {p}. p -> p -> a
[LclId,
 Arity=2,
 Str=<B,A><B,A>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
lvl_suv
  = \ (@p_atN)
      (@a_atS)
      (@p_atP)
      _ [Occ=Dead, Dmd=<B,A>]
      _ [Occ=Dead, Dmd=<B,A>] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl_suw :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl_suw
  = \ (@a_atS) (@p_atP) (@p_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk [Dmd=<S,U>] :: Bool) ->
      case ds_duk of {
        False -> lvl_suv @p_atN @a_atS @p_atP;
        True -> lvl_suw @a_atS @p_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 0 [post-worker-wrapper],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
lvl_suv :: forall {p} {a} {p}. p -> p -> a
[LclId,
 Arity=2,
 Str=<L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
lvl_suv
  = \ (@p_atN)
      (@a_atS)
      (@p_atP)
      _ [Occ=Dead, Dmd=<B,A>]
      _ [Occ=Dead, Dmd=<B,A>] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl_suw :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl_suw
  = \ (@a_atS) (@p_atP) (@p_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk :: Bool) ->
      case ds_duk of {
        False -> lvl_suv @p_atN @a_atS @p_atP;
        True -> lvl_suw @a_atS @p_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Exitification transformation ====================
Result size of Exitification transformation
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
lvl_suv :: forall {p} {a} {p}. p -> p -> a
[LclId,
 Arity=2,
 Str=<L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
lvl_suv
  = \ (@p_atN)
      (@a_atS)
      (@p_atP)
      _ [Occ=Dead, Dmd=<B,A>]
      _ [Occ=Dead, Dmd=<B,A>] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl_suw :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl_suw
  = \ (@a_atS) (@p_atP) (@p_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk :: Bool) ->
      case ds_duk of {
        False -> lvl_suv @p_atN @a_atS @p_atP;
        True -> lvl_suw @a_atS @p_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Levels added: ====================
<lvl_suv,<0,0>>
<lvl_suv,<0,0>>
  = \ <p_atN,<1,0>>
      <a_atS,<1,0>>
      <p_atP,<1,0>>
      <p_atx,<1,0>>
      <q_aty,<1,0>> ->
      GHC.Prim.raise#
        @GHC.Types.Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False
<lvl_suw,<0,0>>
<lvl_suw,<0,0>>
  = \ <a_atS,<0,1>> <p_atP,<0,1>> <p_atN,<0,1>> ->
      GHC.Prim.raise#
        @GHC.Types.Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True
<Foo.f,<0,0>>
<Foo.f,<0,0>>
  = \ <p_atN,<1,0>> <p_atP,<1,0>> <a_atS,<1,0>> <ds_duk,<1,0>> ->
      case ds_duk of <wild_X1,<1,2>> {
        GHC.Types.False -> lvl_suv @p_atN @a_atS @p_atP;
        GHC.Types.True -> lvl_suw @a_atS @p_atP @p_atN
      }
<$trModule_sup,<0,0>>
<$trModule_sup,<0,0>> = "main"#
<$trModule_suq,<0,0>>
<$trModule_suq,<0,0>> = GHC.Types.TrNameS $trModule_sup
<$trModule_sur,<0,0>>
<$trModule_sur,<0,0>> = "Foo"#
<$trModule_sus,<0,0>>
<$trModule_sus,<0,0>> = GHC.Types.TrNameS $trModule_sur
<Foo.$trModule,<0,0>>
<Foo.$trModule,<0,0>>
  = GHC.Types.Module $trModule_suq $trModule_sus



==================== Float out(FOS {Lam = Just 0, Consts = True, OverSatApps = True}) ====================
Result size of Float out(FOS {Lam = Just 0,
                              Consts = True,
                              OverSatApps = True})
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
lvl_suv :: forall {p} {a} {p}. p -> p -> a
[LclId,
 Arity=2,
 Str=<L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
lvl_suv
  = \ (@p_atN)
      (@a_atS)
      (@p_atP)
      _ [Occ=Dead, Dmd=<B,A>]
      _ [Occ=Dead, Dmd=<B,A>] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl_suw :: forall {a} {p} {p}. p -> p -> a
[LclId, Str=b, Cpr=b]
lvl_suw
  = \ (@a_atS) (@p_atP) (@p_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk :: Bool) ->
      case ds_duk of {
        False -> lvl_suv @p_atN @a_atS @p_atP;
        True -> lvl_suw @a_atS @p_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Common sub-expression ====================
Result size of Common sub-expression
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
lvl_suv :: forall {p} {a} {p}. p -> p -> a
[LclId,
 Arity=2,
 Str=<L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
lvl_suv
  = \ (@p_atN)
      (@a_atS)
      (@p_atP)
      _ [Occ=Dead, Dmd=<B,A>]
      _ [Occ=Dead, Dmd=<B,A>] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl_suw :: forall {a} {p} {p}. p -> p -> a
[LclId, Str=b, Cpr=b]
lvl_suw
  = \ (@a_atS) (@p_atP) (@p_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk :: Bool) ->
      case ds_duk of wild_X1 [Dmd=<L,A>] {
        False -> lvl_suv @p_atN @a_atS @p_atP;
        True -> lvl_suw @a_atS @p_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Float inwards ====================
Result size of Float inwards
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
lvl_suv :: forall {p} {a} {p}. p -> p -> a
[LclId,
 Arity=2,
 Str=<L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
lvl_suv
  = \ (@p_atN)
      (@a_atS)
      (@p_atP)
      _ [Occ=Dead, Dmd=<B,A>]
      _ [Occ=Dead, Dmd=<B,A>] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl_suw :: forall {a} {p} {p}. p -> p -> a
[LclId, Str=b, Cpr=b]
lvl_suw
  = \ (@a_atS) (@p_atP) (@p_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk :: Bool) ->
      case ds_duk of wild_X1 [Dmd=<L,A>] {
        False -> lvl_suv @p_atN @a_atS @p_atP;
        True -> lvl_suw @a_atS @p_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Liberate case ====================
Result size of Liberate case
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
lvl_suv :: forall {p} {a} {p}. p -> p -> a
[LclId,
 Arity=2,
 Str=<L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
lvl_suv
  = \ (@p_atN)
      (@a_atS)
      (@p_atP)
      _ [Occ=Dead, Dmd=<B,A>]
      _ [Occ=Dead, Dmd=<B,A>] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl_suw :: forall {a} {p} {p}. p -> p -> a
[LclId, Str=b, Cpr=b]
lvl_suw
  = \ (@a_atS) (@p_atP) (@p_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk :: Bool) ->
      case ds_duk of wild_X1 [Dmd=<L,A>] {
        False -> lvl_suv @p_atN @a_atS @p_atP;
        True -> lvl_suw @a_atS @p_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 0 [post-liberate-case],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
lvl_suv :: forall {p} {a} {p}. p -> p -> a
[LclId,
 Arity=2,
 Str=<L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
lvl_suv
  = \ (@p_atN)
      (@a_atS)
      (@p_atP)
      _ [Occ=Dead, Dmd=<B,A>]
      _ [Occ=Dead, Dmd=<B,A>] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl_suw :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl_suw
  = \ (@a_atS) (@p_atP) (@p_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk :: Bool) ->
      case ds_duk of {
        False -> lvl_suv @p_atN @a_atS @p_atP;
        True -> lvl_suw @a_atS @p_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== SpecConstr ====================
Result size of SpecConstr
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
lvl_suv :: forall {p} {a} {p}. p -> p -> a
[LclId,
 Arity=2,
 Str=<L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
lvl_suv
  = \ (@p_atN)
      (@a_atS)
      (@p_atP)
      _ [Occ=Dead, Dmd=<B,A>]
      _ [Occ=Dead, Dmd=<B,A>] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl_suw :: forall {a} {p} {p}. p -> p -> a
[LclId, Str=b, Cpr=b]
lvl_suw
  = \ (@a_atS) (@p_atP) (@p_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk :: Bool) ->
      case ds_duk of {
        False -> lvl_suv @p_atN @a_atS @p_atP;
        True -> lvl_suw @a_atS @p_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Common sub-expression ====================
Result size of Common sub-expression
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
lvl_suv :: forall {p} {a} {p}. p -> p -> a
[LclId,
 Arity=2,
 Str=<L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
lvl_suv
  = \ (@p_atN)
      (@a_atS)
      (@p_atP)
      _ [Occ=Dead, Dmd=<B,A>]
      _ [Occ=Dead, Dmd=<B,A>] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl_suw :: forall {a} {p} {p}. p -> p -> a
[LclId, Str=b, Cpr=b]
lvl_suw
  = \ (@a_atS) (@p_atP) (@p_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk :: Bool) ->
      case ds_duk of wild_X1 [Dmd=<L,A>] {
        False -> lvl_suv @p_atN @a_atS @p_atP;
        True -> lvl_suw @a_atS @p_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 0 [final],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
lvl_suv :: forall {p} {a} {p}. p -> p -> a
[LclId,
 Arity=2,
 Str=<L,U><L,U>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
lvl_suv
  = \ (@p_atN)
      (@a_atS)
      (@p_atP)
      _ [Occ=Dead, Dmd=<B,A>]
      _ [Occ=Dead, Dmd=<B,A>] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl_suw :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl_suw
  = \ (@a_atS) (@p_atP) (@p_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk :: Bool) ->
      case ds_duk of {
        False -> lvl_suv @p_atN @a_atS @p_atP;
        True -> lvl_suw @a_atS @p_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Demand analysis ====================
Result size of Demand analysis
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
lvl_suv :: forall {p} {a} {p}. p -> p -> a
[LclId,
 Arity=2,
 Str=<B,A><B,A>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
lvl_suv
  = \ (@p_atN)
      (@a_atS)
      (@p_atP)
      _ [Occ=Dead, Dmd=<B,A>]
      _ [Occ=Dead, Dmd=<B,A>] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl_suw :: forall {a} {p} {p}. p -> p -> a
[LclId,
 Str=b,
 Cpr=b,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
lvl_suw
  = \ (@a_atS) (@p_atP) (@p_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p} {p} {a}. Bool -> p -> p -> a
[LclIdX,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
f = \ (@p_atN) (@p_atP) (@a_atS) (ds_duk [Dmd=<S,1*U>] :: Bool) ->
      case ds_duk of {
        False -> lvl_suv @p_atN @a_atS @p_atP;
        True -> lvl_suw @a_atS @p_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sup :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sup = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_suq :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_suq = GHC.Types.TrNameS $trModule_sup

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule_sur :: Addr#
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
$trModule_sur = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule_sus :: GHC.Types.TrName
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
$trModule_sus = GHC.Types.TrNameS $trModule_sur

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Foo.$trModule = GHC.Types.Module $trModule_suq $trModule_sus




==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
Foo.f2 :: forall {p1} {a} {p2}. p1 -> p2 -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>b,
 Cpr=b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
Foo.f2
  = \ (@p_atN) (@a_atS) (@p1_atP) _ [Occ=Dead] _ [Occ=Dead] ->
      raise# @Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Foo.f1 :: forall {a} {p1} {p2}. p2 -> p1 -> a
[GblId, Str=b, Cpr=b]
Foo.f1
  = \ (@a_atS) (@p_atP) (@p1_atN) ->
      raise#
        @Bool
        @'GHC.Types.LiftedRep
        @(p1_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
f :: forall {p1} {p2} {a}. Bool -> p1 -> p2 -> a
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
f = \ (@p_atN) (@p1_atP) (@a_atS) (ds_duk :: Bool) ->
      case ds_duk of {
        False -> Foo.f2 @p_atN @a_atS @p1_atP;
        True -> Foo.f1 @a_atS @p1_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule4 :: Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Foo.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule3 :: GHC.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foo.$trModule3 = GHC.Types.TrNameS Foo.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule2 :: Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Foo.$trModule2 = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule1 :: GHC.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foo.$trModule1 = GHC.Types.TrNameS Foo.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Foo.$trModule = GHC.Types.Module Foo.$trModule3 Foo.$trModule1




==================== CorePrep ====================
Result size of CorePrep
  = {terms: 39, types: 69, coercions: 0, joins: 0/0}

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
Foo.f2 :: forall {p1} {a} {p2}. p1 -> p2 -> a
[GblId, Arity=2, Str=<B,A><B,A>b, Cpr=b, Unf=OtherCon []]
Foo.f2
  = \ (@p_atN) (@a_atS) (@p1_atP) _ [Occ=Dead] _ [Occ=Dead] ->
      GHC.Prim.raise#
        @GHC.Types.Bool @'GHC.Types.LiftedRep @a_atS GHC.Types.False

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Foo.f1 :: forall {a} {p1} {p2}. p2 -> p1 -> a
[GblId, Str=b, Cpr=b]
Foo.f1
  = \ (@a_atS) (@p_atP) (@p1_atN) ->
      GHC.Prim.raise#
        @GHC.Types.Bool
        @'GHC.Types.LiftedRep
        @(p1_atN -> p_atP -> a_atS)
        GHC.Types.True

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
Foo.f :: forall {p1} {p2} {a}. GHC.Types.Bool -> p1 -> p2 -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
Foo.f
  = \ (@p_atN)
      (@p1_atP)
      (@a_atS)
      (ds_sAS [Occ=Once!] :: GHC.Types.Bool) ->
      case ds_sAS of {
        GHC.Types.False -> Foo.f2 @p_atN @a_atS @p1_atP;
        GHC.Types.True -> Foo.f1 @a_atS @p1_atP @p_atN
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule4 :: GHC.Prim.Addr#
[GblId, Unf=OtherCon []]
Foo.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule3 :: GHC.Types.TrName
[GblId, Unf=OtherCon []]
Foo.$trModule3 = GHC.Types.TrNameS Foo.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule2 :: GHC.Prim.Addr#
[GblId, Unf=OtherCon []]
Foo.$trModule2 = "Foo"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule1 :: GHC.Types.TrName
[GblId, Unf=OtherCon []]
Foo.$trModule1 = GHC.Types.TrNameS Foo.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foo.$trModule :: GHC.Types.Module
[GblId, Unf=OtherCon []]
Foo.$trModule = GHC.Types.Module Foo.$trModule3 Foo.$trModule1



